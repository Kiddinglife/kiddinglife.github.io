<!DOCTYPE html>
<html>

  <head>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1">

    <title>Kiddinglife</title>
    <meta name="description" content="">

    <link rel="shortcut icon" href="/favicon.ico?" type="image/x-icon">
    <link rel="icon" href="/favicon.ico?" type="image/x-icon">
    <link rel="stylesheet" href="https://cdn.bootcss.com/font-awesome/4.7.0/css/font-awesome.min.css">
    <link rel="stylesheet" href="https://at.alicdn.com/t/font_8v3czwksspqlg14i.css">
    <link rel="stylesheet" href="/css/main.css ">
    <link rel="canonical" href="http://localhost:1234/">
    <link rel="alternate" type="application/rss+xml" title="Kiddinglife" href="http://localhost:1234/feed.xml ">


    <script>
    // 百度统计代码
    var _hmt = _hmt || [];
    (function() {
      var hm = document.createElement("script");
      hm.src = "//hm.baidu.com/hm.js?cf8506e0ef223e57ff6239944e5d46a4";
      var s = document.getElementsByTagName("script")[0];
      s.parentNode.insertBefore(hm, s);
    })();
    </script>


    <script>
    // google analytics
      (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
      (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
      m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
      })(window,document,'script','https://www.google-analytics.com/analytics.js','ga');

      ga('create', 'UA-72449510-4', 'auto');
      ga('send', 'pageview');

    </script>

</head>


  <body>

    <header id="top">
    <div class="wrapper">
        <a href="/" class="brand">Kiddinglife</a>
        <small>C/C++/PYTHON ENGINEER</small>
        <button id="headerMenu" class="menu"><i class="fa fa-bars"></i></button>
        <nav id="headerNav">
            <ul>
                <li>
                    
                    <a class="active" href="/">
                        
                        <i class="fa fa-home"></i>Home
                    </a>
                </li>

                
                    
                    <li>
                        
                        <a href="/archive/">
                        
                            <i class="fa fa-archive"></i>Archives
                        </a>
                    </li>
                    
                
                    
                    <li>
                        
                        <a href="/category/">
                        
                            <i class="fa fa-th-list"></i>Categories
                        </a>
                    </li>
                    
                
                    
                    <li>
                        
                        <a href="/tag/">
                        
                            <i class="fa fa-tags"></i>Tags
                        </a>
                    </li>
                    
                
                    
                    <li>
                        
                        <a href="/collection/">
                        
                            <i class="fa fa-bookmark"></i>Collections
                        </a>
                    </li>
                    
                
                    
                    <li>
                        
                        <a href="/demo/">
                        
                            <i class="fa fa-play"></i>Demo
                        </a>
                    </li>
                    
                
                    
                    <li>
                        
                        <a href="/about/">
                        
                            <i class="fa fa-heart"></i>About
                        </a>
                    </li>
                    
                
                    
                
                    
                
                    
                
                    
                
                    
                
            </ul>
        </nav>
    </div>
</header>


        <div class="page clearfix" index>
    <div class="left">
        <h1>For My Youth Dedicated to Programming</h1>
        <small>this blog is used to refine my knowledges about IT</small>
        <hr>
        <ul>
            
              <li>
                <h2>
                  <a class="post-link" href="/2017/03/12/ccia-3-1-shared-data-protection/">CCIA-3-shared-data-1</a>
                </h2>
                <div class="label">
                    <div class="label-card">
                        <i class="fa fa-calendar"></i>2017-03-12
                    </div>
                    <div class="label-card">
                        
                    </div>
                    <div class="label-card">
                        
                    </div>

                    <div class="label-card">
                    


<!-- <span class="point">•</span> -->
<span class="categories">
  <i class="fa fa-th-list"></i>
  
    
        <a href="/category/#read" title="Category: read" rel="category">read</a>
    
  

  <!-- <span class="point">•</span> -->
</span>


                    </div>

                    <div class="label-card">
                    
<!-- <span class="point">•</span> -->
<span class="pageTag">
  <i class="fa fa-tags"></i>
  
    
        <a href="/tag/#thread" title="Tag: thread" rel="tag">thread</a>&nbsp;
    
        <a href="/tag/#c++" title="Tag: c++" rel="tag">c++</a>
    
  

</span>

                    </div>
                </div>
                <div class="excerpt">
                    <ul id="markdown-toc">
  <li><a href="#31-problems-with-sharing-data-between-threads" id="markdown-toc-31-problems-with-sharing-data-between-threads">3.1 Problems with sharing data between threads</a>    <ul>
      <li><a href="#311-race-condition" id="markdown-toc-311-race-condition">3.1.1 Race Condition</a></li>
      <li><a href="#312-problematic-race-conditions" id="markdown-toc-312-problematic-race-conditions">3.1.2 Problematic race conditions</a></li>
      <li><a href="#313-avoid-problematic-race-conditions" id="markdown-toc-313-avoid-problematic-race-conditions">3.1.3 Avoid Problematic race conditions</a></li>
    </ul>
  </li>
  <li><a href="#32-protecting-shared-data-with-mutexes" id="markdown-toc-32-protecting-shared-data-with-mutexes">3.2 Protecting shared data with mutexes</a>    <ul>
      <li><a href="#321-use-mutex" id="markdown-toc-321-use-mutex">3.2.1 Use mutex</a></li>
      <li><a href="#322-structure-code-to-protect-right-shared-data" id="markdown-toc-322-structure-code-to-protect-right-shared-data">3.2.2 Structure code to protect right shared data</a></li>
      <li><a href="#323-spotting-race-conditions-inherent-in-interfaces" id="markdown-toc-323-spotting-race-conditions-inherent-in-interfaces">3.2.3 Spotting race conditions inherent in interfaces</a></li>
      <li><a href="#324-deadlock-the-problem-and-a-solution" id="markdown-toc-324-deadlock-the-problem-and-a-solution">3.2.4 Deadlock: the problem and a solution</a></li>
    </ul>
  </li>
</ul>

<h2 id="31-problems-with-sharing-data-between-threads">3.1 Problems with sharing data between threads</h2>
<p>If all shared data is read-only, there’s no problem. However, if data is shared between threads, and <strong>one or more threads</strong> start modifying the data, there’s a lot of potential for trouble.</p>

<p>One concept that’s widely used to help programmers reason about their code is that of invariants—statements that are always true about a particular data structure, These invariants are often broken during an update, especially if the data structure is of any complexity or the update requires modification of more than one value.</p>

<p>Consider a doubly linked list, the steps in deleting an entry from such a list are shown below:</p>
<ol>
  <li>Identify the node to delete (N). a</li>
  <li>Update the link from the node prior to N to point to the node after N. b</li>
  <li>Update the link from the node after N to point to the node prior to N. c</li>
  <li>Delete node N. d</li>
</ol>

<p>if one thread is reading the doubly linked list while another is removing a node, it’s quite possible for the reading thread to see the list with a node only partially removed (because only one of the links has been changed, as in step b of figure 3.1), so the <strong>invariant is broken</strong>.</p>

<p>The consequences of this broken invariant can vary; if the other thread is just reading the list items from left to right in the diagram, it will skip the node being. On the other hand, if the second thread is trying to delete the rightmost node in the diagram, it might end up permanently corrupting the data structure and
eventually crashing the program. this is an example of one of the most common causes of bugs in concurrent code: <strong>a race condition</strong>.</p>

<h3 id="311-race-condition">3.1.1 Race Condition</h3>
<p>In concurrency, a race condition is anything where the outcome depends on the <strong>relative ordering</strong> of execution of operations on two or more threads; the threads race to perform their <strong>respective operations</strong>.</p>

<p>the term race condition is usually used to mean a <strong>problematic race condition</strong>; <strong>benign race conditions</strong> aren’t so interesting and aren’t a cause of bugs. The C++ Standard also defines the term data race to mean the specific type of race condition that arises because of concurrent modification to a single object (see section 5.1.2 for details); data races cause the dreaded undefined behavior and it is problemic race condition.</p>

<p>Take steps in deleting an entry from such a list above as example. Assume thread a operation is to visit each element and thread b operation is to delete element. There are 3 outcomes with diferent relative-ordering executions:</p>
<ol>
  <li>benign race condition outcome: thread a reads deleting element -&gt; thread b deletes left link step b-&gt; thread b deletes right link step c</li>
  <li>problemic race condition outcome: thread b deletes left link step b -&gt; thread a reads deleting element -&gt; thread b deletes right link step c</li>
  <li>benign race condition outcome: thread a reads deleting element -&gt; thread b deletes right link step c -&gt;  thread a reads deleting element</li>
</ol>

<h3 id="312-problematic-race-conditions">3.1.2 Problematic race conditions</h3>
<p>Problematic race conditions typically occur where completing an operation requires modification of two or more distinct pieces of data, such as the two link pointers in the above example.</p>

<p>what happens is that the operation must access two separate pieces of data, these must be modified in separate instructions, and another thread could potentially access the data structure when only one of them has been completed.</p>

<p>Because race conditions are generally timing sensitive, they can often disappear entirely when
the application is run under the debugger, because the debugger affects the timing
of the program, even if only slightly.</p>

<h3 id="313-avoid-problematic-race-conditions">3.1.3 Avoid Problematic race conditions</h3>
<ul>
  <li>The simplest option is to wrap your data structure with a protection mechanism, to ensure that only the thread actually performing a modification can see the intermediate states where the invariants are broken. From the point of view of other threads accessing that data structure,such modifications either haven’t started or have completed.</li>
  <li>Another option is to modify the design of your data structure and its invariants so
that modifications are done as a series of indivisible changes, each of which preserves
the invariants. This is generally referred to as <strong>lock-free</strong> programming and is difficult to get
right.</li>
  <li>Another way of dealing with race conditions is to handle the updates to the data
structure as a transaction, just as updates to a database are done within a transaction.
The required series of data modifications and reads is stored in a transaction log and
then committed in a single step.</li>
</ul>

<p>The most basic mechanism for protecting shared data provided by the C++ Standard is the mutex, so we’ll look at that.</p>

<h2 id="32-protecting-shared-data-with-mutexes">3.2 Protecting shared data with mutexes</h2>
<p>Before accessing a shared data structure, you lock the mutex associated with that data, and when you’ve finished accessing the data structure, you unlock the mutex.</p>

<p>Mutexes are the most general of the data-protection mechanisms available in C++,
but they’re not a silver bullet:</p>
<ul>
  <li>it’s important to structure your code to protect the right data (see section 3.2.2)</li>
  <li>avoid race conditions inherent in your interfaces (see section 3.2.3)</li>
  <li>deadlock (see section 3.2.4)</li>
  <li>protecting either too much or too little data (see section 3.2.8)</li>
</ul>

<h3 id="321-use-mutex">3.2.1 Use mutex</h3>
<p>n C++, you create a mutex by constructing an instance of std::mutex , lock it with a call to the member function lock() , and unlock it with a call to the member function unlock().</p>

<p>The following listing shows how to protect a list that can be accessed by multiple threads using a std::mutex , along with std::lock_guard . Both of these are declared in the <mutex> header.</mutex></p>
<div class="language-c++ highlighter-rouge"><pre class="highlight"><code><span class="cp">#include &lt;list&gt;
#include &lt;mutex&gt;
#include &lt;algorithm&gt;
</span><span class="n">std</span><span class="o">::</span><span class="n">list</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span> <span class="n">some_list</span><span class="p">;</span> <span class="c1">//  1
</span><span class="n">std</span><span class="o">::</span><span class="n">mutex</span> <span class="n">some_mutex</span><span class="p">;</span> <span class="c1">//  2
</span><span class="kt">void</span> <span class="nf">add_to_list</span><span class="p">(</span><span class="kt">int</span> <span class="n">new_value</span><span class="p">)</span>
<span class="p">{</span>
    <span class="n">std</span><span class="o">::</span><span class="n">lock_guard</span><span class="o">&lt;</span><span class="n">std</span><span class="o">::</span><span class="n">mutex</span><span class="o">&gt;</span> <span class="n">guard</span><span class="p">(</span><span class="n">some_mutex</span><span class="p">);</span> <span class="c1">//  3
</span>    <span class="n">some_list</span><span class="p">.</span><span class="n">push_back</span><span class="p">(</span><span class="n">new_value</span><span class="p">);</span>
<span class="p">}</span>
<span class="kt">bool</span> <span class="nf">list_contains</span><span class="p">(</span><span class="kt">int</span> <span class="n">value_to_find</span><span class="p">)</span>
<span class="p">{</span>
    <span class="n">std</span><span class="o">::</span><span class="n">lock_guard</span><span class="o">&lt;</span><span class="n">std</span><span class="o">::</span><span class="n">mutex</span><span class="o">&gt;</span> <span class="n">guard</span><span class="p">(</span><span class="n">some_mutex</span><span class="p">);</span> <span class="c1">//  4
</span>    <span class="k">return</span> <span class="n">std</span><span class="o">::</span><span class="n">find</span><span class="p">(</span><span class="n">some_list</span><span class="p">.</span><span class="n">begin</span><span class="p">(),</span> <span class="n">some_list</span><span class="p">.</span><span class="n">end</span><span class="p">(),</span> <span class="n">value_to_find</span><span class="p">)</span> <span class="o">!=</span> <span class="n">some_list</span><span class="p">.</span><span class="n">end</span><span class="p">();</span>
<span class="p">}</span>
</code></pre>
</div>
<p>there’s a single global variable <em>1</em>, and it’s protected with a corresponding global instance of std::mutex <em>2</em>.
The use of <code class="highlighter-rouge">std::lock_guard&lt;std::mutex&gt;</code> in <code class="highlighter-rouge">add_to_list()</code> <em>3</em> and again in <code class="highlighter-rouge">list_contains()</code> <em>4</em> means that the accesses in these functions are mutually exclusive: list_contains() will never see the list partway
through a modification by <code class="highlighter-rouge">add_to_list()</code>.</p>

<p>If all the member functions of he class lock the mutex before accessing any other data members and unlock it when done, the data is nicely protected from all comers.</p>

<p>Well, that’s not quite true, as the astute among you will have noticed: if one of the member functions returns a pointer or reference to the protected data, then it doesn’t matter that the member functions all lock the mutex in a nice orderly fashion, because you’ve just blown a big hole in the protection.</p>

<p><em>Any code that has access to that pointer or reference can now access (and potentially modify) the protected data without locking the mutex.</em></p>

<p>Protecting data with a mutex therefore requires careful interface design, to
ensure that the mutex is locked before there’s any access to the protected data and
that there are no backdoors.</p>

<h3 id="322-structure-code-to-protect-right-shared-data">3.2.2 Structure code to protect right shared data</h3>
<p>At one level, checking for stray pointers or references is easy; as long as none of the member functions return a pointer or reference to the protected data to their caller either via their return value or via an out parameter, the data is safe.</p>

<p>those functions that aren’t under your control might store the pointer or reference in a place where it can later be used without the protection of the mutex. Particularly dangerous in this regard are functions that are supplied at runtime via a function argument or other means, as in the next listing.</p>
<div class="language-c++ highlighter-rouge"><pre class="highlight"><code><span class="k">class</span> <span class="nc">some_data</span>
<span class="p">{</span>
        <span class="kt">int</span> <span class="n">a</span><span class="p">;</span>
        <span class="n">std</span><span class="o">::</span><span class="n">string</span> <span class="n">b</span><span class="p">;</span>
    <span class="k">public</span><span class="o">:</span>
        <span class="kt">void</span> <span class="n">do_something</span><span class="p">();</span>
<span class="p">};</span>
<span class="k">class</span> <span class="nc">data_wrapper</span>
<span class="p">{</span>
    <span class="k">private</span><span class="o">:</span>
        <span class="n">some_data</span> <span class="n">data</span><span class="p">;</span>
        <span class="n">std</span><span class="o">::</span><span class="n">mutex</span> <span class="n">m</span><span class="p">;</span>
    <span class="k">public</span><span class="o">:</span>
        <span class="k">template</span><span class="o">&lt;</span><span class="k">typename</span> <span class="n">Function</span><span class="o">&gt;</span>
        <span class="kt">void</span> <span class="n">process_data</span><span class="p">(</span><span class="n">Function</span> <span class="n">func</span><span class="p">)</span>
        <span class="p">{</span>
            <span class="n">std</span><span class="o">::</span><span class="n">lock_guard</span><span class="o">&lt;</span><span class="n">std</span><span class="o">::</span><span class="n">mutex</span><span class="o">&gt;</span> <span class="n">l</span><span class="p">(</span><span class="n">m</span><span class="p">);</span>
            <span class="n">func</span><span class="p">(</span><span class="n">data</span><span class="p">);</span> <span class="c1">//  1  Pass “protected” data to user-supplied function
</span>        <span class="p">}</span>
<span class="p">};</span>
<span class="n">some_data</span><span class="o">*</span> <span class="n">unprotected</span><span class="p">;</span>
<span class="kt">void</span> <span class="nf">malicious_function</span><span class="p">(</span><span class="n">some_data</span><span class="o">&amp;</span> <span class="n">protected_data</span><span class="p">)</span>
<span class="p">{</span>
    <span class="n">unprotected</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">protected_data</span><span class="p">;</span>
<span class="p">}</span>
<span class="n">data_wrapper</span> <span class="n">x</span><span class="p">;</span>
<span class="kt">void</span> <span class="nf">foo</span><span class="p">()</span>
<span class="p">{</span>
    <span class="n">x</span><span class="p">.</span><span class="n">process_data</span><span class="p">(</span><span class="n">malicious_function</span><span class="p">);</span> <span class="c1">//  2 Pass in a malicious function
</span>    <span class="n">unprotected</span><span class="o">-&gt;</span><span class="n">do_something</span><span class="p">();</span> <span class="c1">//  3 Unprotected access to protected data
</span><span class="p">}</span>
</code></pre>
</div>
<p>you have a guideline to follow, which will help you in these cases:<br />
<em>Don’t pass pointers and references to protected data outside the scope of the lock, whether by
returning them from a function, storing them in externally visible memory, or passing them as
arguments to user-supplied functions.</em></p>

<p>Although this is a common mistake when trying to use mutexes to protect shared
data, it’s far from the only potential pitfall. As you’ll see in the next section, <strong>it’s still
possible to have race conditions, even when data is protected with a mutex</strong>.</p>

<h3 id="323-spotting-race-conditions-inherent-in-interfaces">3.2.3 Spotting race conditions inherent in interfaces</h3>
<p>Consider a stack:</p>
<div class="language-c++ highlighter-rouge"><pre class="highlight"><code><span class="k">template</span><span class="o">&lt;</span><span class="k">typename</span> <span class="n">T</span><span class="p">,</span><span class="k">typename</span> <span class="n">Container</span><span class="o">=</span><span class="n">std</span><span class="o">::</span><span class="n">deque</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span> <span class="o">&gt;</span>
<span class="k">class</span> <span class="nc">stack</span>
<span class="p">{</span>
    <span class="k">public</span><span class="o">:</span>
    <span class="k">explicit</span> <span class="n">stack</span><span class="p">(</span><span class="k">const</span> <span class="n">Container</span><span class="o">&amp;</span><span class="p">);</span>
    <span class="k">explicit</span> <span class="n">stack</span><span class="p">(</span><span class="n">Container</span><span class="o">&amp;&amp;</span> <span class="o">=</span> <span class="n">Container</span><span class="p">());</span>
    <span class="k">template</span> <span class="o">&lt;</span><span class="k">class</span> <span class="nc">Alloc</span><span class="o">&gt;</span> <span class="k">explicit</span> <span class="n">stack</span><span class="p">(</span><span class="k">const</span> <span class="n">Alloc</span><span class="o">&amp;</span><span class="p">);</span>
    <span class="k">template</span> <span class="o">&lt;</span><span class="k">class</span> <span class="nc">Alloc</span><span class="o">&gt;</span> <span class="n">stack</span><span class="p">(</span><span class="k">const</span> <span class="n">Container</span><span class="o">&amp;</span><span class="p">,</span> <span class="k">const</span> <span class="n">Alloc</span><span class="o">&amp;</span><span class="p">);</span>
    <span class="k">template</span> <span class="o">&lt;</span><span class="k">class</span> <span class="nc">Alloc</span><span class="o">&gt;</span> <span class="n">stack</span><span class="p">(</span><span class="n">Container</span><span class="o">&amp;&amp;</span><span class="p">,</span> <span class="k">const</span> <span class="n">Alloc</span><span class="o">&amp;</span><span class="p">);</span>
    <span class="k">template</span> <span class="o">&lt;</span><span class="k">class</span> <span class="nc">Alloc</span><span class="o">&gt;</span> <span class="n">stack</span><span class="p">(</span><span class="n">stack</span><span class="o">&amp;&amp;</span><span class="p">,</span> <span class="k">const</span> <span class="n">Alloc</span><span class="o">&amp;</span><span class="p">);</span>
    <span class="kt">bool</span> <span class="n">empty</span><span class="p">()</span> <span class="k">const</span><span class="p">;</span>
    <span class="kt">size_t</span> <span class="n">size</span><span class="p">()</span> <span class="k">const</span><span class="p">;</span>
    <span class="n">T</span><span class="o">&amp;</span> <span class="n">top</span><span class="p">();</span>
    <span class="n">T</span> <span class="k">const</span><span class="o">&amp;</span> <span class="n">top</span><span class="p">()</span> <span class="k">const</span><span class="p">;</span>
    <span class="kt">void</span> <span class="n">push</span><span class="p">(</span><span class="n">T</span> <span class="k">const</span><span class="o">&amp;</span><span class="p">);</span>
    <span class="kt">void</span> <span class="n">push</span><span class="p">(</span><span class="n">T</span><span class="o">&amp;&amp;</span><span class="p">);</span>
    <span class="kt">void</span> <span class="n">pop</span><span class="p">();</span>
    <span class="kt">void</span> <span class="n">swap</span><span class="p">(</span><span class="n">stack</span><span class="o">&amp;&amp;</span><span class="p">);</span>
<span class="p">};</span>
</code></pre>
</div>
<p>In order for a thread to safely pop a node:</p>
<ul>
  <li>firstly you need to ensure that  you’re preventing concurrent accesses to three nodes:<br />
the node being deleted (node2) and the nodes on either side (node 1 and 3).</li>
  <li>secondly you need to ensure that  you’re preventing concurrent accesses to three interfaces:<br />
empty(),top() and pop().</li>
</ul>

<p>think about the reason for this whole problem in term of <em><strong>multi-level-invariant</strong></em> shown below:</p>
<div class="language-c++ highlighter-rouge"><pre class="highlight"><code><span class="c1">// to maitain level 1 invarirant, lock concurrent accesss to stack varaibles inside each interface
// to maitain level 2 invariant, lock concurrent accesss to stack interfaces inside caller scope
</span><span class="n">stack</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span> <span class="n">s</span><span class="p">;</span>
<span class="k">if</span><span class="p">(</span><span class="o">!</span><span class="n">s</span><span class="p">.</span><span class="n">empty</span><span class="p">())</span> <span class="c1">//1
</span><span class="p">{</span>
    <span class="kt">int</span> <span class="k">const</span> <span class="n">value</span><span class="o">=</span><span class="n">s</span><span class="p">.</span><span class="n">top</span><span class="p">();</span> <span class="c1">//2
</span>    <span class="n">s</span><span class="p">.</span><span class="n">pop</span><span class="p">();</span> <span class="c1">//3
</span>    <span class="n">do_something</span><span class="p">(</span><span class="n">value</span><span class="p">);</span>
<span class="p">}</span>
</code></pre>
</div>
<p>calling top() on an empty stack is undefined behavior. With a shared stack object, this call sequence is no longer
safe, because there might be a call to pop() from another thread that removes the last element in between the call to 
empty() and the call to top()._This is yet another race condition and far more insidious than the undefined behavior of 
the empty() / top() race;</p>

<p>the use of a mutex internally to protect the stack contents doesn’t prevent it; it’s a consequence of the interface. 
This problem is not unique to a mutex-based implementation; it’s an interface problem, so the race conditions would still
occur with a lock-free implementation.</p>

<p>A more radical change to the interface that combines the calls to top() and pop() under the protection of the mutex can
resolved PRC <em>but a combined call can lead to issues if the copy constructor for the objects on the stack can throw an exception.</em></p>

<p>Why? Assume you have <code class="highlighter-rouge">stack&lt;vector&lt;int&gt;&gt;</code>. If the pop() function was defined to return the value popped, 
as well as remove it from the stack,you have a potential problem: the value being popped is returned to the caller only
after the stack has been modified, but the process of copying the data to return to the caller might throw an exception. 
If this happens, the data just popped is lost; it has been removed from the stack, but the copy was unsuccessful!</p>

<p>So the designers of the std::stack interface helpfully split the operation in two: get the top element ( top() )
and then remove it from the stack ( pop() ), so that if you can’t safely copy the data, it
stays on the stack. If the problem was lack of heap memory, maybe the application can
free some memory and try again.</p>

<p><em>Unfortunately, it’s precisely this split that you’re trying to avoid in eliminating the race condition! Thankfully, 
there are alternatives, but they aren’t without cost.</em></p>

<ol>
  <li>PASS IN A REFERENCE<br />
pass a reference to a variable in which you wish to receive the popped value as an argument 
in the call to pop():
    <div class="language-c++ highlighter-rouge"><pre class="highlight"><code><span class="kt">void</span> <span class="n">pop</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;&amp;</span> <span class="n">result</span><span class="p">);</span>
<span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span> <span class="n">result</span><span class="p">;</span>
<span class="n">some_stack</span><span class="p">.</span><span class="n">pop</span><span class="p">(</span><span class="n">result</span><span class="p">);</span>
</code></pre>
    </div>
  </li>
  <li>
    <p>RETURN A POINTER <br />
return a pointer to the popped item rather than return the item by value. <br />
The advantage here is that pointers can be freely copied without throwing an exception, 
so you’ve avoided Cargill’s exception problem.  <br />
The disadvantage is that returning a pointer requires a means of managing the memory allocated to the
object, and for simple types such as integers, the overhead of such memory manage-
ment can exceed the cost of just returning the type by value</p>
  </li>
  <li>provide both of 2 and 3<br />
 Flexibility should never be ruled out, especially in generic code</li>
</ol>

<p>Based on suggestions shown above, this is an thread-safe-stack:</p>
<div class="language-c++ highlighter-rouge"><pre class="highlight"><code><span class="cp">#include &lt;exception&gt;
#include &lt;memory&gt;
#include &lt;mutex&gt;
#include &lt;stack&gt;
</span><span class="k">struct</span> <span class="n">empty_stack</span><span class="o">:</span> <span class="n">std</span><span class="o">::</span><span class="n">exception</span>
<span class="p">{</span>
    <span class="k">const</span> <span class="kt">char</span><span class="o">*</span>	<span class="n">what</span><span class="p">()</span> <span class="k">const</span> <span class="k">throw</span><span class="p">()</span> <span class="p">{};</span>
<span class="p">};</span>
<span class="k">template</span><span class="o">&lt;</span><span class="k">typename</span> <span class="n">T</span><span class="o">&gt;</span>
<span class="k">class</span> <span class="nc">threadsafe_stack</span>
<span class="p">{</span>
<span class="k">private</span><span class="o">:</span>
    <span class="n">std</span><span class="o">::</span><span class="n">stack</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span> <span class="n">data</span><span class="p">;</span>
    <span class="k">mutable</span>	<span class="n">std</span><span class="o">::</span><span class="n">mutex</span> <span class="n">m</span><span class="p">;</span>
<span class="k">public</span><span class="o">:</span>
    <span class="n">threadsafe_stack</span><span class="p">(){}</span>
    <span class="n">threadsafe_stack</span><span class="p">(</span><span class="k">const</span> <span class="n">threadsafe_stack</span><span class="o">&amp;</span> <span class="n">other</span><span class="p">)</span>
    <span class="p">{</span>
        <span class="c1">// 1 This stack implementation is actually copyable—the copy constructor 
</span>        <span class="c1">// locks the mutex in the source object and then copies the internal stack.
</span>        <span class="c1">// You do the copy in the constructor body  rather than the member initializer 
</span>        <span class="c1">// list in order to ensure that the mutex is held across the copy.
</span>        <span class="n">std</span><span class="o">::</span><span class="n">lock_guard</span><span class="o">&lt;</span><span class="n">std</span><span class="o">::</span><span class="n">mutex</span><span class="o">&gt;</span> <span class="n">lock</span><span class="p">(</span><span class="n">m</span><span class="p">);</span> 
        <span class="n">data</span> <span class="o">=</span> <span class="n">other</span><span class="p">.</span><span class="n">data</span><span class="p">;</span>	
    <span class="p">}</span>
    <span class="n">threadsafe_stack</span><span class="o">&amp;</span> <span class="k">operator</span><span class="o">=</span><span class="p">(</span><span class="k">const</span> <span class="n">threadsafe_stack</span><span class="o">&amp;</span><span class="p">)</span><span class="o">=</span><span class="k">delete</span><span class="p">;</span>
    <span class="kt">void</span> <span class="nf">push</span><span class="p">(</span><span class="n">T</span>	<span class="n">new_value</span><span class="p">)</span>
    <span class="p">{</span>
        <span class="n">std</span><span class="o">::</span><span class="n">lock_guard</span><span class="o">&lt;</span><span class="n">std</span><span class="o">::</span><span class="n">mutex</span><span class="o">&gt;</span> <span class="n">lock</span><span class="p">(</span><span class="n">m</span><span class="p">);</span> 
        <span class="n">data</span><span class="p">.</span><span class="n">push</span><span class="p">(</span><span class="n">new_value</span><span class="p">);</span>
    <span class="p">}</span>
    <span class="n">std</span><span class="o">::</span><span class="n">shared_ptr</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span> <span class="n">pop</span><span class="p">()</span>
    <span class="p">{</span>
        <span class="n">std</span><span class="o">::</span><span class="n">lock_guard</span><span class="o">&lt;</span><span class="n">std</span><span class="o">::</span><span class="n">mutex</span><span class="o">&gt;</span> <span class="n">lock</span><span class="p">(</span><span class="n">m</span><span class="p">);</span>     
        <span class="c1">//2 Check for empty before trying to pop value
</span>        <span class="k">if</span><span class="p">(</span><span class="n">data</span><span class="p">.</span><span class="n">empty</span><span class="p">())</span> <span class="k">throw</span> <span class="n">empty_stack</span><span class="p">();</span> 
        <span class="c1">//3 allocate return value before pop it out
</span>        <span class="n">std</span><span class="o">::</span><span class="n">shared_ptr</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span> <span class="k">const</span> <span class="n">res</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">make_shared</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span><span class="p">(</span><span class="n">data</span><span class="p">.</span><span class="n">top</span><span class="p">()));</span>
        <span class="n">data</span><span class="p">.</span><span class="n">pop</span><span class="p">();</span>
        <span class="k">return</span> <span class="n">res</span><span class="p">;</span>
    <span class="p">}</span>
    <span class="kt">void</span> <span class="n">pop</span><span class="p">(</span><span class="n">T</span><span class="o">&amp;</span>	<span class="n">value</span><span class="p">)</span>
    <span class="p">{</span>
        <span class="n">std</span><span class="o">::</span><span class="n">lock_guard</span><span class="o">&lt;</span><span class="n">std</span><span class="o">::</span><span class="n">mutex</span><span class="o">&gt;</span> <span class="n">lock</span><span class="p">(</span><span class="n">m</span><span class="p">);</span>  
        <span class="c1">//4 some threads remove element from backdoor interfaces eg, call data.pop()
</span>        <span class="k">if</span><span class="p">(</span><span class="n">data</span><span class="p">.</span><span class="n">empty</span><span class="p">())</span> <span class="k">throw</span> <span class="n">empty_stack</span><span class="p">();</span>      
        <span class="n">value</span><span class="o">=</span><span class="n">data</span><span class="p">.</span><span class="n">top</span><span class="p">();</span>
        <span class="n">data</span><span class="p">.</span><span class="n">pop</span><span class="p">();</span>
    <span class="p">}</span>
    <span class="kt">bool</span> <span class="n">empty</span><span class="p">()</span> <span class="k">const</span>
    <span class="p">{</span>
        <span class="n">std</span><span class="o">::</span><span class="n">lock_guard</span><span class="o">&lt;</span><span class="n">std</span><span class="o">::</span><span class="n">mutex</span><span class="o">&gt;</span> <span class="n">lock</span><span class="p">(</span><span class="n">m</span><span class="p">);</span>
        <span class="k">return</span> <span class="n">data</span><span class="p">.</span><span class="n">empty</span><span class="p">();</span>
    <span class="p">}</span>
</code></pre>
</div>

<p>Problems with mutexes can also arise from:</p>
<ol>
  <li>locking at too large a granularity<br />
the extreme situation is a single global mutex that protects all shared data.</li>
  <li>locking at too small a granularity<br />
the protection doesn’t cover the entirety of the desired operation (this is problem )</li>
</ol>

<p>One issue with fine-grained locking schemes is that sometimes you need more than one mutex locked in order to protect 
all the data in an operation.</p>

<p>if you end up having to lock two or more mutexes for a given operation, there’s
another potential problem lurking in the wings: <em><strong>deadlock</strong></em>. This is almost the opposite
of a race condition: rather than two threads racing to be first, each one is waiting for
the other, so neither makes any progress.</p>

<h3 id="324-deadlock-the-problem-and-a-solution">3.2.4 Deadlock: the problem and a solution</h3>


                </div>
                <div class="read-all">
                    <a  href="/2017/03/12/ccia-3-1-shared-data-protection/"><i class="fa fa-newspaper-o"></i>Read All</a>
                </div>
                <hr>
              </li>
            
              <li>
                <h2>
                  <a class="post-link" href="/2017/03/07/csapp-1-preface/">CS:APP-1-Introduction</a>
                </h2>
                <div class="label">
                    <div class="label-card">
                        <i class="fa fa-calendar"></i>2017-03-07
                    </div>
                    <div class="label-card">
                        
                    </div>
                    <div class="label-card">
                        
                    </div>

                    <div class="label-card">
                    


<!-- <span class="point">•</span> -->
<span class="categories">
  <i class="fa fa-th-list"></i>
  
    
        <a href="/category/#read" title="Category: read" rel="category">read</a>
    
  

  <!-- <span class="point">•</span> -->
</span>


                    </div>

                    <div class="label-card">
                    
<!-- <span class="point">•</span> -->
<span class="pageTag">
  <i class="fa fa-tags"></i>
  
    
        <a href="/tag/#os" title="Tag: os" rel="tag">os</a>
    
  

</span>

                    </div>
                </div>
                <div class="excerpt">
                    <ul id="markdown-toc">
  <li><a href="#what-to-be-read" id="markdown-toc-what-to-be-read">What To Be Read</a></li>
  <li><a href="#assumptions" id="markdown-toc-assumptions">Assumptions</a></li>
  <li><a href="#aims" id="markdown-toc-aims">Aims</a></li>
  <li><a href="#what-to-be-expected" id="markdown-toc-what-to-be-expected">What To Be Expected</a></li>
  <li><a href="#my-way-to-read" id="markdown-toc-my-way-to-read">My Way to Read</a></li>
</ul>

<h2 id="what-to-be-read">What To Be Read</h2>
<p>CS:APP is the short name for a great book called 
<strong><em>“Computer Systems: A Programmer’s Perspective”</em></strong></p>

<h2 id="assumptions">Assumptions</h2>
<ul>
  <li>Use the term “Unix” as an umbrella term for systems having Unix as 
their heritage, including Solaris, Mac OS, and Linux.</li>
  <li>Have some familiarity with C or C++.</li>
  <li>Do not assume any prior experience with hardware, machine language, 
or assembly-language programming.</li>
</ul>

<h2 id="aims">Aims</h2>
<ul>
  <li>
    <p>Present the fundamental concepts in ways that you will find useful right away. 
You will also be prepared to delve deeper, studying such topics as compilers, computer 
architecture, operating systems, em-bedded systems, and networking.</p>
  </li>
  <li>
    <p>Other systems books are written from a builder’s perspective. This book is written from a 
<strong>programmer’s perspective</strong>, describing how application programmers can use their knowledge 
of a system to write better programs.</p>
  </li>
  <li>
    <p>If you study and learn the concepts in this book, you will be on your way to
becoming the rare “<strong>power programmer</strong>” who knows how things work and how
to fix them when they break.</p>
  </li>
</ul>

<h2 id="what-to-be-expected">What To Be Expected</h2>
<p>Become Power Programmer.</p>

<h2 id="my-way-to-read">My Way to Read</h2>
<ul>
  <li>More rely on diagrams to illustrate complicated concepts.</li>
  <li>Highlight emphasises.</li>
  <li>Code sample program by my own.</li>
  <li>Go over previous chapters frequently</li>
  <li>Find more materials on topic in each chapter to refine my understandings.</li>
</ul>


                </div>
                <div class="read-all">
                    <a  href="/2017/03/07/csapp-1-preface/"><i class="fa fa-newspaper-o"></i>Read All</a>
                </div>
                <hr>
              </li>
            
              <li>
                <h2>
                  <a class="post-link" href="/2017/03/06/ccia-2-thread-management/">CCIA-2-basic-thread-mangement</a>
                </h2>
                <div class="label">
                    <div class="label-card">
                        <i class="fa fa-calendar"></i>2017-03-06
                    </div>
                    <div class="label-card">
                        
                    </div>
                    <div class="label-card">
                        
                    </div>

                    <div class="label-card">
                    


<!-- <span class="point">•</span> -->
<span class="categories">
  <i class="fa fa-th-list"></i>
  
    
        <a href="/category/#read" title="Category: read" rel="category">read</a>
    
  

  <!-- <span class="point">•</span> -->
</span>


                    </div>

                    <div class="label-card">
                    
<!-- <span class="point">•</span> -->
<span class="pageTag">
  <i class="fa fa-tags"></i>
  
    
        <a href="/tag/#thread" title="Tag: thread" rel="tag">thread</a>&nbsp;
    
        <a href="/tag/#c++" title="Tag: c++" rel="tag">c++</a>
    
  

</span>

                    </div>
                </div>
                <div class="excerpt">
                    <ul id="markdown-toc">
  <li><a href="#21-线程管理的基础-basic-thread-mangement" id="markdown-toc-21-线程管理的基础-basic-thread-mangement">2.1 线程管理的基础 Basic Thread Mangement</a>    <ul>
      <li><a href="#211-launching-a-thread-启动线程" id="markdown-toc-211-launching-a-thread-启动线程">2.1.1 Launching a thread 启动线程</a></li>
      <li><a href="#212-等待线程完成-waiting-for-a-thread-to-complete" id="markdown-toc-212-等待线程完成-waiting-for-a-thread-to-complete">2.1.2 等待线程完成 Waiting for a thread to complete</a>        <ul>
          <li><a href="#2121-特殊情况下的等待--waiting-in-exceptional-circumstances" id="markdown-toc-2121-特殊情况下的等待--waiting-in-exceptional-circumstances">2.1.2.1 特殊情况下的等待  Waiting in exceptional circumstances</a></li>
        </ul>
      </li>
      <li><a href="#213-后台运行线程-running-threads-in-the-background" id="markdown-toc-213-后台运行线程-running-threads-in-the-background">2.1.3 后台运行线程 Running threads in the background</a></li>
    </ul>
  </li>
  <li><a href="#22-向线程函数传递参数-passing-arguments-to-a-thread-function" id="markdown-toc-22-向线程函数传递参数-passing-arguments-to-a-thread-function">2.2 向线程函数传递参数 Passing arguments to a thread function</a></li>
  <li><a href="#23-transferring-ownership-of-a-thread-转移线程所有权" id="markdown-toc-23-transferring-ownership-of-a-thread-转移线程所有权">2.3 Transferring ownership of a thread 转移线程所有权</a></li>
  <li><a href="#24-运行时决定线程数量" id="markdown-toc-24-运行时决定线程数量">2.4 运行时决定线程数量</a></li>
  <li><a href="#25-识别线程-identifying" id="markdown-toc-25-识别线程-identifying">2.5 识别线程 Identifying</a></li>
</ul>

<h2 id="21-线程管理的基础-basic-thread-mangement">2.1 线程管理的基础 Basic Thread Mangement</h2>
<p>每个程序至少有一个线程：执行main()函数的线程，其余线程有其各自的入口函数. 线程与原始线程(以main()为入口函数的线程)同时运行。如同main()函数执行完会退出一样，当线程执行完入口函数后，线程也会退出. 在为一个线程创建了一个 std::thread 对象后，需要等待这个线程结束。 <br />
Every C++ program has at least one thread, which is started by the C++ runtime: the thread running main(). Your program can then launch additional threads that have another function as the entry point. These threads then run concurrently with each other and with the initial thread. Just as the program exits when the program returns from main(), when the specified entry point function returns, the thread exits. As you’ll see, if you have a std::thread object for a thread, you can wait for it to finish。</p>

<h3 id="211-launching-a-thread-启动线程">2.1.1 Launching a thread 启动线程</h3>
<p>使用C++线程库启动线程，可以归结为构造 std::thread 对象:    <br />
Starting a thread using the C++ Thread Library always boils down to constructing a std::thread object:</p>
<div class="language-c++ highlighter-rouge"><pre class="highlight"><code><span class="k">class</span> <span class="nc">background_task</span>
<span class="p">{</span>
<span class="k">public</span><span class="o">:</span>
<span class="kt">void</span> <span class="k">operator</span><span class="p">()()</span> <span class="k">const</span>
<span class="p">{</span>
<span class="n">do_something</span><span class="p">();</span>
<span class="n">do_something_else</span><span class="p">();</span>
<span class="p">}</span>
<span class="p">};</span>
<span class="n">background_task</span> <span class="n">f</span><span class="p">;</span>
<span class="n">std</span><span class="o">::</span><span class="kr">thread</span> <span class="n">my_thread</span><span class="p">(</span><span class="n">f</span><span class="p">);</span>
</code></pre>
</div>

<p>有件事需要注意，当把函数对象传入到线程构造函数中时，如果你传递了一个临时变量，而不是一个命名的变量；C++编译器会将其解析为函数声明，而不是类型对象的定义。  <br />
One thing to consider when passing a function object to the thread constructor is to avoid what is dubbed “C++’s most vexing parse.” If you pass a temporary rather Basic thread management 17 than a named variable, then the syntax can be the same as that of a function declaration, in which case the compiler interprets it as such, rather than an object definition.</p>

<p>For example,</p>
<div class="language-c++ highlighter-rouge"><pre class="highlight"><code><span class="n">std</span><span class="o">::</span><span class="kr">thread</span> <span class="n">my_thread</span><span class="p">(</span><span class="n">background_task</span><span class="p">());</span>
</code></pre>
</div>
<p>这里相当与声明了一个名为my_thread的函数，这个函数带有一个参数(函数指针指向没有参
数并返回background_task对象的函数)，返回一个 std::thread 对象的函数，而非启动了一个线程。
declares a function my_thread that takes a single parameter (of type pointer to a function taking no parameters and returning a background_task object) and returns a std::thread object, rather than launching a new thread.</p>

<p>使用在前面命名函数对象的方式，或使用多组括号①，或使用新统一的初始化语法②，可以避免这个问题。
You can avoid this by naming your function object as shown previously, by using an extra set of parentheses, or
by using the new uniform initialization syntax, for example:</p>
<div class="language-c++ highlighter-rouge"><pre class="highlight"><code><span class="c1">// 1
</span><span class="n">std</span><span class="o">::</span><span class="kr">thread</span> <span class="n">my_thread</span><span class="p">((</span><span class="n">background_task</span><span class="p">()));</span> 
<span class="c1">// 2
</span><span class="n">std</span><span class="o">::</span><span class="kr">thread</span> <span class="n">my_thread</span><span class="p">{</span><span class="n">background_task</span><span class="p">()};</span> 
<span class="c1">// 3
</span><span class="n">std</span><span class="o">::</span><span class="kr">thread</span> <span class="n">my_thread</span><span class="p">([]{</span>
<span class="n">do_something</span><span class="p">();</span>
<span class="n">do_something_else</span><span class="p">();</span>
<span class="p">});</span>
</code></pre>
</div>

<p>启动了线程，你需要明确是要等待线程结束，还是让其自主运行。如果 std::thread 对象销毁之前还没有做出决定，程序就会终止( std::thread 的析构函数会调用 std::terminate() )。因此，即便是有异常存在，也需要确保线程能够正确的加入(joined)或分离(detached).  <br />
It’s therefore imperative that you ensure that the thread is correctly joined or detached, even in the presence of exceptions。</p>

<p>如果不等待线程，就必须保证线程结束之前，可访问的数据得有效性。<br />
If you don’t wait for your thread to finish, then you need to ensure that the data accessed by the thread is valid until the thread has finished with it.</p>
<div class="language-c++ highlighter-rouge"><pre class="highlight"><code><span class="c1">//函数已经结束，线程依旧访问局部变量 
//A function that returns while a thread still has access to local variables
</span><span class="k">struct</span> <span class="n">func</span>
<span class="p">{</span>
<span class="kt">int</span><span class="o">&amp;</span> <span class="n">i</span><span class="p">;</span>
<span class="n">func</span><span class="p">(</span><span class="kt">int</span><span class="o">&amp;</span> <span class="n">i_</span><span class="p">)</span> <span class="o">:</span> <span class="n">i</span><span class="p">(</span><span class="n">i_</span><span class="p">)</span> <span class="p">{}</span>
<span class="kt">void</span> <span class="k">operator</span><span class="p">()</span> <span class="p">()</span>
<span class="p">{</span>
   <span class="k">for</span> <span class="p">(</span><span class="kt">unsigned</span> <span class="n">j</span><span class="o">=</span><span class="mi">0</span> <span class="p">;</span> <span class="n">j</span><span class="o">&lt;</span><span class="mi">1000000</span> <span class="p">;</span> <span class="o">++</span><span class="n">j</span><span class="p">)</span>
   <span class="p">{</span>
      <span class="c1">// 1. 潜在访问隐患：悬空引用 Potential access to dangling reference
</span>      <span class="n">do_something</span><span class="p">(</span><span class="n">i</span><span class="p">);</span> 
   <span class="p">}</span>
<span class="p">}</span>
<span class="p">};</span>
<span class="kt">void</span> <span class="nf">oops</span><span class="p">()</span>
<span class="p">{</span>
   <span class="kt">int</span> <span class="n">some_local_state</span><span class="o">=</span><span class="mi">0</span><span class="p">;</span>
   <span class="n">func</span> <span class="n">my_func</span><span class="p">(</span><span class="n">some_local_state</span><span class="p">);</span>
   <span class="n">std</span><span class="o">::</span><span class="kr">thread</span> <span class="n">my_thread</span><span class="p">(</span><span class="n">my_func</span><span class="p">);</span>
   <span class="c1">// 2. 不等待线程结束 do not wait for thread to finish
</span>   <span class="n">my_thread</span><span class="p">.</span><span class="n">detach</span><span class="p">();</span> 
<span class="p">}</span> <span class="c1">// 3. 函数退出时新线程可能还在运行  New thread might still be running when func exits
</span></code></pre>
</div>
<p>处理这种情况的常规方法 ：  <br />
common way to handle this scenario
1 数据复制到线程中，而非共享数据<br />
make the thread function self-contained and copy the data into the thread rather than sharing the data。   <br />
2 使用一个能访问局部变量的函数去创建线程是一个糟糕的主意(除非十分确定线程会在函数完成前结束，例如使用join)。<br />
ensure that the thread has completed execution before the function exits by joining with the thread.</p>

<h3 id="212-等待线程完成-waiting-for-a-thread-to-complete">2.1.2 等待线程完成 Waiting for a thread to complete</h3>
<p>join()是简单粗暴的等待线程完成或不等待。当你需要对等待中的线程有更灵活的控制时，比
如，看一下某个线程是否结束，或者只等待一段时间(超过时间就判定为超时)。想要做到这
些，你需要使用其他机制来完成，比如条件变量和期待(futures).  <br />
If you need more fine-grained control over waiting for a thread, such as to
check whether a thread is finished, or to wait only a certain period of time, then you
have to use alternative mechanisms such as condition variables and futures。</p>

<p>调用join()的行为，还清理了线程相关的存储部分，这样 std::thread 对象将不再与已经
完成的线程有任何关联。这意味着，只能对一个线程使用一次join();一旦已经使用过
join()， std::thread 对象就不能再次加入了，当对其使用joinable()时，将返回否（false）。<br />
The act of calling join() also cleans up any storage associated
with the thread, so the std::thread object is no longer associated with the nowfinished
thread; it isn’t associated with any thread. This means that you can call
join() only once for a given thread; once you’ve called join(), the std::thread
object is no longer joinable, and joinable() will return false.</p>

<h4 id="2121-特殊情况下的等待--waiting-in-exceptional-circumstances">2.1.2.1 特殊情况下的等待  Waiting in exceptional circumstances</h4>
<p>如前所述，需要对一个还未销毁的 std::thread 对象使用join()或detach()。如果想要分离一
个线程，可以在线程启动后，直接使用detach()进行分离。如果打算等待对应线程，则需要细
心挑选调用join()的位置。当在线程运行之后产生异常，在join()调用之前抛出，就意味着很这
次调用会被跳过. <br />
you need to ensure that you’ve called either join() or detach() before a std::thread object is destroyed. If you’re detaching a thread, you can usually call detach() immediately after the thread has been started, so this isn’t a
problem. But if you’re intending to wait for the thread, you need to pick carefully the place in the code where you call join(). This means that the call to join() is liable to be skipped if an exception is thrown after the thread has been started but before the call to join().</p>
<div class="language-c++ highlighter-rouge"><pre class="highlight"><code><span class="k">struct</span> <span class="n">func</span><span class="p">;</span> 
<span class="kt">void</span> <span class="nf">f</span><span class="p">()</span>
<span class="p">{</span>
   <span class="kt">int</span> <span class="n">some_local_state</span><span class="o">=</span><span class="mi">0</span><span class="p">;</span>
   <span class="n">func</span> <span class="n">my_func</span><span class="p">(</span><span class="n">some_local_state</span><span class="p">);</span>
   <span class="n">std</span><span class="o">::</span><span class="kr">thread</span> <span class="n">t</span><span class="p">(</span><span class="n">my_func</span><span class="p">);</span>
<span class="k">try</span>
<span class="p">{</span>
   <span class="n">do_something_in_current_thread</span><span class="p">();</span>
<span class="p">}</span>
<span class="k">catch</span><span class="p">(...)</span>
<span class="p">{</span>
   <span class="n">t</span><span class="p">.</span><span class="n">join</span><span class="p">();</span> <span class="c1">// 1
</span>   <span class="k">throw</span><span class="p">;</span>
<span class="p">}</span>
<span class="n">t</span><span class="p">.</span><span class="n">join</span><span class="p">();</span> <span class="c1">// 2
</span><span class="p">}</span>

<span class="c1">// Using RAII to wait for a thread to complete
</span><span class="k">class</span> <span class="nc">thread_guard</span>
<span class="p">{</span>
   <span class="n">std</span><span class="o">::</span><span class="kr">thread</span><span class="o">&amp;</span> <span class="n">t</span><span class="p">;</span>
   <span class="k">public</span><span class="o">:</span>
   <span class="k">explicit</span> <span class="n">thread_guard</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="kr">thread</span><span class="o">&amp;</span> <span class="n">t_</span><span class="p">)</span><span class="o">:</span>
   <span class="n">t</span><span class="p">(</span><span class="n">t_</span><span class="p">){}</span>
   <span class="o">~</span><span class="n">thread_guard</span><span class="p">()</span>
   <span class="p">{</span>
      <span class="k">if</span><span class="p">(</span><span class="n">t</span><span class="p">.</span><span class="n">joinable</span><span class="p">())</span>
      <span class="p">{</span>
         <span class="n">t</span><span class="p">.</span><span class="n">join</span><span class="p">();</span>
      <span class="p">}</span>
   <span class="p">}</span>
   <span class="n">thread_guard</span><span class="p">(</span><span class="n">thread_guard</span> <span class="k">const</span><span class="o">&amp;</span><span class="p">)</span><span class="o">=</span><span class="k">delete</span><span class="p">;</span>
   <span class="n">thread_guard</span><span class="o">&amp;</span> <span class="k">operator</span><span class="o">=</span><span class="p">(</span><span class="n">thread_guard</span> <span class="k">const</span><span class="o">&amp;</span><span class="p">)</span><span class="o">=</span><span class="k">delete</span><span class="p">;</span>
<span class="p">};</span>
<span class="k">struct</span> <span class="n">func</span><span class="p">;</span>
<span class="kt">void</span> <span class="nf">f</span><span class="p">()</span>
<span class="p">{</span>
   <span class="kt">int</span> <span class="n">some_local_state</span><span class="o">=</span><span class="mi">0</span><span class="p">;</span>
   <span class="n">func</span> <span class="n">my_func</span><span class="p">(</span><span class="n">some_local_state</span><span class="p">);</span>
   <span class="n">std</span><span class="o">::</span><span class="kr">thread</span> <span class="n">t</span><span class="p">(</span><span class="n">my_func</span><span class="p">);</span>
   <span class="n">thread_guard</span> <span class="n">g</span><span class="p">(</span><span class="n">t</span><span class="p">);</span>
   <span class="n">do_something_in_current_thread</span><span class="p">();</span>
<span class="p">}</span>
</code></pre>
</div>

<h3 id="213-后台运行线程-running-threads-in-the-background">2.1.3 后台运行线程 Running threads in the background</h3>
<p>如果线程分离，那么就不可能有 std::thread 对象能引用它，分离线程
的确在后台运行，所以分离线程不能被加入. C++运行库保证，当线程退出时，
相关资源的能够正确回收，后台线程的归属和控制C++运行库都会处理.<br />
if a thread becomes detached, it isn’t possible to obtain a
std::thread object that references it, so it can no longer be joined. Detached threads
truly run in the background; ownership and control are passed over to the C++ Runtime
Library, which ensures that the resources associated with the thread are correctly
reclaimed when the thread exits.</p>

<p>这种线程的特点就是长时间运行；线程的生命周期可能会从某一个应用起始到结束，可能会在后台监视文件系统，还有可能对缓存进行清理，亦或对数据结构进行优化.<br />
Such threads are typically long-running; they may well run for almost the entire lifetime of
the application, performing a background task such as monitoring the filesystem,
clearing unused entries out of object caches, or optimizing data structures.</p>

<p>如果不是后台线程，但是若能确定该线程什么时候结束，或者是”发后即忘”(fire andforget)的任务的也可以使用detached线程。
At the other extreme, it may make sense to use a detached thread where there’s another
mechanism for identifying when the thread has completed or where the thread is
used for a “fire and forget” task.</p>
<div class="language-c++ highlighter-rouge"><pre class="highlight"><code><span class="kt">void</span> <span class="nf">edit_document</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">string</span> <span class="k">const</span><span class="o">&amp;</span> <span class="n">filename</span><span class="p">)</span>
<span class="p">{</span>
   <span class="n">open_document_and_display_gui</span><span class="p">(</span><span class="n">filename</span><span class="p">);</span>
   <span class="k">while</span><span class="p">(</span><span class="o">!</span><span class="n">done_editing</span><span class="p">())</span>
   <span class="p">{</span>
   <span class="n">user_command</span> <span class="n">cmd</span><span class="o">=</span><span class="n">get_user_input</span><span class="p">();</span>
   <span class="k">if</span><span class="p">(</span><span class="n">cmd</span><span class="p">.</span><span class="n">type</span><span class="o">==</span><span class="n">open_new_document</span><span class="p">)</span>
   <span class="p">{</span>
      <span class="n">std</span><span class="o">::</span><span class="n">string</span> <span class="k">const</span> <span class="n">new_name</span><span class="o">=</span><span class="n">get_filename_from_user</span><span class="p">();</span>
      <span class="n">std</span><span class="o">::</span><span class="kr">thread</span> <span class="n">t</span><span class="p">(</span><span class="n">edit_document</span><span class="p">,</span><span class="n">new_name</span><span class="p">);</span> <span class="c1">// 1
</span>      <span class="n">t</span><span class="p">.</span><span class="n">detach</span><span class="p">();</span> <span class="c1">// 2
</span>   <span class="p">}</span>
   <span class="k">else</span>
   <span class="p">{</span>
      <span class="n">process_user_input</span><span class="p">(</span><span class="n">cmd</span><span class="p">);</span>
   <span class="p">}</span>
<span class="p">}</span>
<span class="p">}</span>
</code></pre>
</div>

<h2 id="22-向线程函数传递参数-passing-arguments-to-a-thread-function">2.2 向线程函数传递参数 Passing arguments to a thread function</h2>
<p>需要注意的是，默认参数要拷贝到线程独立内存中，即使参数是引用的形式。<br />
it’s important to bear in mind that by default the arguments are copied into internal
storage, where they can be accessed by the newly created thread of execution,
even if the corresponding parameter in the function is expecting a reference。</p>
<div class="language-c++ highlighter-rouge"><pre class="highlight"><code><span class="kt">void</span> <span class="n">f</span><span class="p">(</span><span class="kt">int</span> <span class="n">i</span><span class="p">,</span> <span class="n">std</span><span class="o">::</span><span class="n">string</span> <span class="k">const</span><span class="o">&amp;</span> <span class="n">s</span><span class="p">);</span>
<span class="n">std</span><span class="o">::</span><span class="kr">thread</span> <span class="n">t</span><span class="p">(</span><span class="n">f</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="s">"hello"</span><span class="p">);</span>
</code></pre>
</div>
<p>代码创建了一个调用f(3, “hello”)的线程。注意，函数f需要一个 std::string 对象作为第二个
参数，但这里使用的是字符串的字面值，也就是 char const * 类型。之后，在线程的上下文
中完成字面值向 std::string 对象的转化。需要特别要注意，当指向动态变量的指针作为参数
传递给线程的情况，代码如下：<br />
This creates a new thread of execution associated with t, which calls f(3,”hello”).
Note that even though f takes a std::string as the second parameter, the string literal
is passed as a char const* and converted to a std::string only in the context of
the new thread. This is particularly important when the argument supplied is a
pointer to an automatic variable, as follows:</p>
<div class="language-c++ highlighter-rouge"><pre class="highlight"><code><span class="kt">void</span> <span class="n">f</span><span class="p">(</span><span class="kt">int</span> <span class="n">i</span><span class="p">,</span><span class="n">std</span><span class="o">::</span><span class="n">string</span> <span class="k">const</span><span class="o">&amp;</span> <span class="n">s</span><span class="p">);</span>
<span class="kt">void</span> <span class="nf">oops</span><span class="p">(</span><span class="kt">int</span> <span class="n">some_param</span><span class="p">)</span>
<span class="p">{</span>
<span class="kt">char</span> <span class="n">buffer</span><span class="p">[</span><span class="mi">1024</span><span class="p">];</span> <span class="c1">// 1
</span><span class="n">sprintf</span><span class="p">(</span><span class="n">buffer</span><span class="p">,</span> <span class="s">"%i"</span><span class="p">,</span><span class="n">some_param</span><span class="p">);</span>
<span class="n">std</span><span class="o">::</span><span class="kr">thread</span> <span class="n">t</span><span class="p">(</span><span class="n">f</span><span class="p">,</span><span class="mi">3</span><span class="p">,</span><span class="n">buffer</span><span class="p">);</span> <span class="c1">// 2
</span><span class="n">t</span><span class="p">.</span><span class="n">detach</span><span class="p">();</span>
<span class="p">}</span>
</code></pre>
</div>
<p>这种情况下，buffer②是一个指针变量，指向本地变量，通过std::thread对象构造函数copy到thread内部成员中②。然而，函数有很大的可能，会在thread将字面值转化成 std::string 对象之前崩溃(oops)，从而导致线程的一些未定义行为。解决方案就是将字面值转化为 std::string 对象，然后传递给thread，从而拷贝buffer到thread中去. <br />
In this case, it’s the pointer to the local variable buffer B that’s passed through to the
new thread c, and there’s a significant chance that the function oops will exit before
the buffer has been converted to a std::string on the new thread, thus leading to
undefined behavior. The solution is to cast to std::string before passing the buffer
to the std::thread constructor.</p>
<div class="language-c++ highlighter-rouge"><pre class="highlight"><code><span class="kt">void</span> <span class="n">f</span><span class="p">(</span><span class="kt">int</span> <span class="n">i</span><span class="p">,</span><span class="n">std</span><span class="o">::</span><span class="n">string</span> <span class="k">const</span><span class="o">&amp;</span> <span class="n">s</span><span class="p">);</span>
<span class="kt">void</span> <span class="nf">not_oops</span><span class="p">(</span><span class="kt">int</span> <span class="n">some_param</span><span class="p">)</span>
<span class="p">{</span>
<span class="kt">char</span> <span class="n">buffer</span><span class="p">[</span><span class="mi">1024</span><span class="p">];</span>
<span class="n">sprintf</span><span class="p">(</span><span class="n">buffer</span><span class="p">,</span><span class="s">"%i"</span><span class="p">,</span><span class="n">some_param</span><span class="p">);</span>
<span class="c1">// 使用std::string，避免悬垂指针 Using std::string avoids dangling pointer
</span><span class="n">std</span><span class="o">::</span><span class="kr">thread</span> <span class="n">t</span><span class="p">(</span><span class="n">f</span><span class="p">,</span><span class="mi">3</span><span class="p">,</span><span class="n">std</span><span class="o">::</span><span class="n">string</span><span class="p">(</span><span class="n">buffer</span><span class="p">));</span> 
<span class="c1">// poesudo code in constructor of thread
// std::string internal_str = std::string(buffer); // value-copy
</span><span class="n">t</span><span class="p">.</span><span class="n">detach</span><span class="p">();</span>
<span class="p">}</span>
</code></pre>
</div>
<p>不过，也有相反的情况：你想要的就是引用拷贝 而非默认的值拷贝，你需要更新你传递的引用，例如：  <br />
It’s also possible to get the reverse scenario: the object is copied, and what you
wanted was a reference. This might happen if the thread is updating a data structure
that’s passed in by reference, for example:</p>
<div class="language-c++ highlighter-rouge"><pre class="highlight"><code><span class="kt">void</span> <span class="n">update_data_for_widget</span><span class="p">(</span><span class="n">widget_id</span> <span class="n">w</span><span class="p">,</span><span class="n">widget_data</span><span class="o">&amp;</span> <span class="n">data</span><span class="p">);</span> <span class="c1">// 1
</span><span class="kt">void</span> <span class="nf">oops_again</span><span class="p">(</span><span class="n">widget_id</span> <span class="n">w</span><span class="p">)</span>
<span class="p">{</span>
   <span class="n">widget_data</span> <span class="n">data</span><span class="p">;</span>
   <span class="n">std</span><span class="o">::</span><span class="kr">thread</span> <span class="n">t</span><span class="p">(</span><span class="n">update_data_for_widget</span><span class="p">,</span><span class="n">w</span><span class="p">,</span><span class="n">data</span><span class="p">);</span> <span class="c1">// 2
</span>   <span class="n">display_status</span><span class="p">();</span>
   <span class="n">t</span><span class="p">.</span><span class="n">join</span><span class="p">();</span>
   <span class="n">process_widget_data</span><span class="p">(</span><span class="n">data</span><span class="p">);</span> <span class="c1">// 3
</span><span class="p">}</span>
</code></pre>
</div>
<p>当线程调用
update_data_for_widget函数时，传递给函数的参数是data变量内部拷贝的引用，而非数据本
身的引用。因此，当线程结束时，内部拷贝数据将会在数据更新阶段被销毁，且 process_widget_data将会接收到没有修改的data变量③。
使用 std::bind ，就可以解决这个问题，使用 std::ref 将参数转换成引用的形式。这种情况下，可将线程的调用，改成以下形式：<br />
Consequently, when the
thread finishes, these updates will be discarded as the internal copies of the supplied arguments are destroyed, and process_widget_data will be passed an unchanged data d rather than a correctly updated version. you need to wrap the arguments that really need to be references in std::ref. In this case, if you change the thread invocation to：</p>
<div class="language-c++ highlighter-rouge"><pre class="highlight"><code><span class="n">std</span><span class="o">::</span><span class="kr">thread</span> <span class="n">t</span><span class="p">(</span><span class="n">update_data_for_widget</span><span class="p">,</span><span class="n">w</span><span class="p">,</span><span class="n">std</span><span class="o">::</span><span class="n">ref</span><span class="p">(</span><span class="n">data</span><span class="p">));</span>
</code></pre>
</div>

<h2 id="23-transferring-ownership-of-a-thread-转移线程所有权">2.3 Transferring ownership of a thread 转移线程所有权</h2>
<p>假设要写一个函数，该函数会创建一个运行在后台的新线程， 并且会返回该线程的所有权给函数调用者；
或完全与之相反：创建一个线程，并将所有权通过参数传递给另外一个函数，并且在该函数作用域内join该线程。
总之，新线程的所有权都需要转移。 明执行线程的所有权可以在 std::thread 实例中移动，下面将展示一个例
子。例子中，创建了两个执行线程，并且在 std::thread 实例之间(t1,t2和t3)转移所有权： <br />
the ownership of a particular thread of execution can be moved between std::thread instances, as in the following example. The example 26 CHAPTER 2 Managing threads shows the creation of two threads of execution and the transfer of ownership of those threads among three std::thread instances, t1, t2, and t3:</p>
<div class="language-c++ highlighter-rouge"><pre class="highlight"><code><span class="kt">void</span> <span class="n">some_function</span><span class="p">();</span>
<span class="kt">void</span> <span class="n">some_other_function</span><span class="p">();</span>

<span class="cm">/* 1 a new thread is started and associated with t1. */</span>
<span class="n">std</span><span class="o">::</span><span class="kr">thread</span> <span class="n">t1</span><span class="p">(</span><span class="n">some_function</span><span class="p">);</span>

<span class="cm">/* 2
 * ownership is then transferred over to t2 when t2 is constructed, 
 * by invoking std::move() to explicitly move ownership. 
 * At this point, t1 no longer has an associated thread of execution; 
 * the thread running some_function is now associated with t2.
 */</span>
<span class="n">std</span><span class="o">::</span><span class="kr">thread</span> <span class="n">t2</span><span class="o">=</span><span class="n">std</span><span class="o">::</span><span class="n">move</span><span class="p">(</span><span class="n">t1</span><span class="p">);</span>

<span class="cm">/* 3
 * Then, a new thread is started and associated with a temporary std::thread
 * object d. The subsequent transfer of ownership into t1 doesn’t require a call to std::
 * move() to explicitly move ownership, because the owner is a temporary object—moving
 * from temporaries is automatic and implicit.
 */</span>
<span class="n">t1</span><span class="o">=</span><span class="n">std</span><span class="o">::</span><span class="kr">thread</span><span class="p">(</span><span class="n">some_other_function</span><span class="p">);</span> 

<span class="cm">/* 4
 * t3 is default constructed e, which means that it’s created without any associated
 * thread of execution. Ownership of the thread currently associated with t2 is transferred
 * into t3 f, again with an explicit call to std::move(), because t2 is a named object. After
 * all these moves, t1 is associated with the thread running some_other_function, t2 has no
 * associated thread, and t3 is associated with the thread running some_function.
 */</span>
<span class="n">std</span><span class="o">::</span><span class="kr">thread</span> <span class="n">t3</span><span class="p">;</span> 
<span class="n">t3</span><span class="o">=</span><span class="n">std</span><span class="o">::</span><span class="n">move</span><span class="p">(</span><span class="n">t2</span><span class="p">);</span> 

<span class="cm">/* 5
 * The final move g transfers ownership of the thread running some_function back
 * to t1 where it started. But in this case t1 already had an associated thread (which was
 * running some_other_function), so std::terminate() is called to terminate the
 * program. This is done for consistency with the std::thread destructor. You saw in
 * section 2.1.1 that you must explicitly wait for a thread to complete or detach it before
 * destruction, and the same applies to assignment: you can’t just “drop” a thread by
 * assigning a new value to the std::thread object that manages it.
 */</span>
<span class="n">t1</span><span class="o">=</span><span class="n">std</span><span class="o">::</span><span class="n">move</span><span class="p">(</span><span class="n">t3</span><span class="p">);</span> <span class="c1">// 赋值操作将使程序崩溃 This assignment will terminate program!
</span></code></pre>
</div>
<p>The move support in std::thread means that ownership can readily be transferred out of a function:</p>
<div class="language-c++ highlighter-rouge"><pre class="highlight"><code><span class="c1">// 函数返回 std::thread 对象 Returning a std::thread from a function
</span><span class="n">std</span><span class="o">::</span><span class="kr">thread</span> <span class="n">f</span><span class="p">()</span>
<span class="p">{</span>
   <span class="kt">void</span> <span class="n">some_function</span><span class="p">();</span>
   <span class="k">return</span> <span class="n">std</span><span class="o">::</span><span class="kr">thread</span><span class="p">(</span><span class="n">some_function</span><span class="p">);</span>
<span class="p">}</span>
<span class="n">std</span><span class="o">::</span><span class="kr">thread</span> <span class="n">g</span><span class="p">()</span>
<span class="p">{</span>
   <span class="kt">void</span> <span class="n">some_other_function</span><span class="p">(</span><span class="kt">int</span><span class="p">);</span>
   <span class="n">std</span><span class="o">::</span><span class="kr">thread</span> <span class="n">t</span><span class="p">(</span><span class="n">some_other_function</span><span class="p">,</span><span class="mi">42</span><span class="p">);</span>
   <span class="k">return</span> <span class="n">t</span><span class="p">;</span>
<span class="p">}</span>
</code></pre>
</div>

<p>Likewise, if ownership should be transferred into a function, it can just accept an
instance of std::thread by value as one of the parameters, as shown here:</p>
<div class="language-c++ highlighter-rouge"><pre class="highlight"><code><span class="c1">// 传递 std::thread 对象到函数 pass in a std::thread to a function
</span><span class="kt">void</span> <span class="n">f</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="kr">thread</span> <span class="n">t</span><span class="p">);</span>
<span class="kt">void</span> <span class="nf">g</span><span class="p">()</span>
<span class="p">{</span>
<span class="kt">void</span> <span class="n">some_function</span><span class="p">();</span>
<span class="c1">// tempory thread instance and use std::move implicitely
</span><span class="n">f</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="kr">thread</span><span class="p">(</span><span class="n">some_function</span><span class="p">));</span>
<span class="n">std</span><span class="o">::</span><span class="kr">thread</span> <span class="n">t</span><span class="p">(</span><span class="n">some_function</span><span class="p">);</span>
<span class="c1">// named thread instance t and so has to use std::move explicitely
</span><span class="n">f</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">move</span><span class="p">(</span><span class="n">t</span><span class="p">));</span>
<span class="p">}</span>
</code></pre>
</div>

<div class="language-c++ highlighter-rouge"><pre class="highlight"><code><span class="k">class</span> <span class="nc">scoped_thread</span>
<span class="p">{</span>
<span class="n">std</span><span class="o">::</span><span class="kr">thread</span> <span class="n">t</span><span class="p">;</span>
<span class="k">public</span><span class="o">:</span>
<span class="k">explicit</span> <span class="n">scoped_thread</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="kr">thread</span> <span class="n">t_</span><span class="p">)</span><span class="o">:</span> <span class="c1">// 1
</span><span class="n">t</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">move</span><span class="p">(</span><span class="n">t_</span><span class="p">))</span>
<span class="p">{</span>
<span class="k">if</span><span class="p">(</span><span class="o">!</span><span class="n">t</span><span class="p">.</span><span class="n">joinable</span><span class="p">())</span> <span class="c1">// 2
</span><span class="k">throw</span> <span class="n">std</span><span class="o">::</span><span class="n">logic_error</span><span class="p">(</span><span class="err">“</span><span class="n">No</span> <span class="kr">thread</span><span class="err">”</span><span class="p">);</span>
<span class="p">}</span>
<span class="o">~</span><span class="n">scoped_thread</span><span class="p">()</span>
<span class="p">{</span>
<span class="n">t</span><span class="p">.</span><span class="n">join</span><span class="p">();</span> <span class="c1">// 3
</span><span class="p">}</span>
<span class="n">scoped_thread</span><span class="p">(</span><span class="n">scoped_thread</span> <span class="k">const</span><span class="o">&amp;</span><span class="p">)</span><span class="o">=</span><span class="k">delete</span><span class="p">;</span>
<span class="n">scoped_thread</span><span class="o">&amp;</span> <span class="k">operator</span><span class="o">=</span><span class="p">(</span><span class="n">scoped_thread</span> <span class="k">const</span><span class="o">&amp;</span><span class="p">)</span><span class="o">=</span><span class="k">delete</span><span class="p">;</span>
<span class="p">};</span>
<span class="k">struct</span> <span class="n">func</span><span class="p">;</span> 
<span class="kt">void</span> <span class="nf">f</span><span class="p">()</span>
<span class="p">{</span>
<span class="kt">int</span> <span class="n">some_local_state</span><span class="p">;</span>
<span class="n">scoped_thread</span> <span class="n">t</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="kr">thread</span><span class="p">(</span><span class="n">func</span><span class="p">(</span><span class="n">some_local_state</span><span class="p">)));</span> <span class="c1">// 4
</span><span class="n">do_something_in_current_thread</span><span class="p">();</span>
<span class="p">}</span>
</code></pre>
</div>

<p>std::thread 对象的容器，如果这个容器是移动敏感的(比如，标准中的 std::vector&lt;&gt; )，那么移动操作同样适用于这些容器.<br />
The move support in std::thread also allows for containers of std::thread objects, if those containers are move aware (like the updated std::vector&lt;&gt;).</p>
<div class="language-c++ highlighter-rouge"><pre class="highlight"><code><span class="kt">void</span> <span class="n">do_work</span><span class="p">(</span><span class="kt">unsigned</span> <span class="n">id</span><span class="p">);</span>
<span class="kt">void</span> <span class="nf">f</span><span class="p">()</span>
<span class="p">{</span>
<span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="n">std</span><span class="o">::</span><span class="kr">thread</span><span class="o">&gt;</span> <span class="n">threads</span><span class="p">;</span>
<span class="k">for</span><span class="p">(</span><span class="kt">unsigned</span> <span class="n">i</span><span class="o">=</span><span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="mi">20</span><span class="p">;</span> <span class="o">++</span><span class="n">i</span><span class="p">)</span>
<span class="p">{</span>
<span class="n">threads</span><span class="p">.</span><span class="n">push_back</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="kr">thread</span><span class="p">(</span><span class="n">do_work</span><span class="p">,</span><span class="n">i</span><span class="p">));</span> <span class="c1">// 产生线程 spawn threads
</span><span class="p">}</span>
<span class="n">std</span><span class="o">::</span><span class="n">for_each</span><span class="p">(</span><span class="n">threads</span><span class="p">.</span><span class="n">begin</span><span class="p">(),</span><span class="n">threads</span><span class="p">.</span><span class="n">end</span><span class="p">(),</span>
<span class="n">std</span><span class="o">::</span><span class="n">mem_fn</span><span class="p">(</span><span class="o">&amp;</span><span class="n">std</span><span class="o">::</span><span class="kr">thread</span><span class="o">::</span><span class="n">join</span><span class="p">));</span> <span class="c1">// 对每个线程调用join() call join on each thread
</span><span class="p">}</span>
</code></pre>
</div>

<h2 id="24-运行时决定线程数量">2.4 运行时决定线程数量</h2>
<p>将 std::thread 放入 std::vector 是向线程自动化管理迈出的第一步：并非为这些线程创建独
立的变量，并且将他们直接加入，可以把它们当做一个组。创建一组线程(数量在运行时确定)，可使得这一步迈的更大.<br />
Putting std::thread objects in a std::vector is a step toward automating the management of those threads. You can take this a step further by creating a dynamic number of threads determined at runtime.</p>
<div class="language-c++ highlighter-rouge"><pre class="highlight"><code><span class="k">template</span><span class="o">&lt;</span><span class="k">typename</span> <span class="n">Iterator</span><span class="p">,</span><span class="k">typename</span> <span class="n">T</span><span class="o">&gt;</span>
<span class="k">struct</span> <span class="n">accumulate_block</span>
<span class="p">{</span>
<span class="kt">void</span> <span class="k">operator</span><span class="p">()(</span><span class="n">Iterator</span> <span class="n">first</span><span class="p">,</span><span class="n">Iterator</span> <span class="n">last</span><span class="p">,</span><span class="n">T</span><span class="o">&amp;</span> <span class="n">result</span><span class="p">)</span>
<span class="p">{</span>
<span class="n">result</span><span class="o">=</span><span class="n">std</span><span class="o">::</span><span class="n">accumulate</span><span class="p">(</span><span class="n">first</span><span class="p">,</span><span class="n">last</span><span class="p">,</span><span class="n">result</span><span class="p">);</span>
<span class="p">}</span>
<span class="p">};</span>
<span class="k">template</span><span class="o">&lt;</span><span class="k">typename</span> <span class="n">Iterator</span><span class="p">,</span><span class="k">typename</span> <span class="n">T</span><span class="o">&gt;</span>
<span class="n">T</span> <span class="n">parallel_accumulate</span><span class="p">(</span><span class="n">Iterator</span> <span class="n">first</span><span class="p">,</span><span class="n">Iterator</span> <span class="n">last</span><span class="p">,</span><span class="n">T</span> <span class="n">init</span><span class="p">)</span>
<span class="p">{</span>
<span class="kt">unsigned</span> <span class="kt">long</span> <span class="k">const</span> <span class="n">length</span><span class="o">=</span><span class="n">std</span><span class="o">::</span><span class="n">distance</span><span class="p">(</span><span class="n">first</span><span class="p">,</span><span class="n">last</span><span class="p">);</span>
<span class="k">if</span><span class="p">(</span><span class="o">!</span><span class="n">length</span><span class="p">)</span> <span class="c1">// 1
</span><span class="k">return</span> <span class="n">init</span><span class="p">;</span>
<span class="kt">unsigned</span> <span class="kt">long</span> <span class="k">const</span> <span class="n">min_per_thread</span><span class="o">=</span><span class="mi">25</span><span class="p">;</span>
<span class="kt">unsigned</span> <span class="kt">long</span> <span class="k">const</span> <span class="n">max_threads</span><span class="o">=</span>
<span class="p">(</span><span class="n">length</span><span class="o">+</span><span class="n">min_per_thread</span><span class="o">-</span><span class="mi">1</span><span class="p">)</span><span class="o">/</span><span class="n">min_per_thread</span><span class="p">;</span> <span class="c1">// 2
</span><span class="kt">unsigned</span> <span class="kt">long</span> <span class="k">const</span> <span class="n">hardware_threads</span><span class="o">=</span>
<span class="n">std</span><span class="o">::</span><span class="kr">thread</span><span class="o">::</span><span class="n">hardware_concurrency</span><span class="p">();</span>
<span class="kt">unsigned</span> <span class="kt">long</span> <span class="k">const</span> <span class="n">num_threads</span><span class="o">=</span> <span class="c1">// 3
</span><span class="n">std</span><span class="o">::</span><span class="n">min</span><span class="p">(</span><span class="n">hardware_threads</span> <span class="o">!=</span> <span class="mi">0</span> <span class="o">?</span> <span class="n">hardware_threads</span> <span class="o">:</span> <span class="mi">2</span><span class="p">,</span> <span class="n">max_threads</span><span class="p">);</span>
<span class="kt">unsigned</span> <span class="kt">long</span> <span class="k">const</span> <span class="n">block_size</span><span class="o">=</span><span class="n">length</span><span class="o">/</span><span class="n">num_threads</span><span class="p">;</span> <span class="c1">// 4
</span><span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span> <span class="n">results</span><span class="p">(</span><span class="n">num_threads</span><span class="p">);</span>
<span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="n">std</span><span class="o">::</span><span class="kr">thread</span><span class="o">&gt;</span> <span class="n">threads</span><span class="p">(</span><span class="n">num_threads</span><span class="o">-</span><span class="mi">1</span><span class="p">);</span> <span class="c1">// 5
</span><span class="n">Iterator</span> <span class="n">block_start</span><span class="o">=</span><span class="n">first</span><span class="p">;</span>
<span class="k">for</span><span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">i</span><span class="o">=</span><span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="p">(</span><span class="n">num_threads</span><span class="o">-</span><span class="mi">1</span><span class="p">);</span> <span class="o">++</span><span class="n">i</span><span class="p">)</span>
<span class="p">{</span>
<span class="n">Iterator</span> <span class="n">block_end</span><span class="o">=</span><span class="n">block_start</span><span class="p">;</span>
<span class="n">std</span><span class="o">::</span><span class="n">advance</span><span class="p">(</span><span class="n">block_end</span><span class="p">,</span><span class="n">block_size</span><span class="p">);</span> <span class="c1">// 6
</span><span class="n">threads</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">=</span><span class="n">std</span><span class="o">::</span><span class="kr">thread</span><span class="p">(</span> <span class="c1">// 7
</span><span class="n">accumulate_block</span><span class="o">&lt;</span><span class="n">Iterator</span><span class="p">,</span><span class="n">T</span><span class="o">&gt;</span><span class="p">(),</span>
<span class="n">block_start</span><span class="p">,</span><span class="n">block_end</span><span class="p">,</span><span class="n">std</span><span class="o">::</span><span class="n">ref</span><span class="p">(</span><span class="n">results</span><span class="p">[</span><span class="n">i</span><span class="p">]));</span>
<span class="n">block_start</span><span class="o">=</span><span class="n">block_end</span><span class="p">;</span> <span class="c1">// 8
</span><span class="p">}</span>
<span class="n">accumulate_block</span><span class="o">&lt;</span><span class="n">Iterator</span><span class="p">,</span><span class="n">T</span><span class="o">&gt;</span><span class="p">()(</span>
<span class="n">block_start</span><span class="p">,</span><span class="n">last</span><span class="p">,</span><span class="n">results</span><span class="p">[</span><span class="n">num_threads</span><span class="o">-</span><span class="mi">1</span><span class="p">]);</span> <span class="c1">// 9
</span><span class="n">std</span><span class="o">::</span><span class="n">for_each</span><span class="p">(</span><span class="n">threads</span><span class="p">.</span><span class="n">begin</span><span class="p">(),</span><span class="n">threads</span><span class="p">.</span><span class="n">end</span><span class="p">(),</span>
<span class="n">std</span><span class="o">::</span><span class="n">mem_fn</span><span class="p">(</span><span class="o">&amp;</span><span class="n">std</span><span class="o">::</span><span class="kr">thread</span><span class="o">::</span><span class="n">join</span><span class="p">));</span> <span class="c1">// 10
</span><span class="k">return</span> <span class="n">std</span><span class="o">::</span><span class="n">accumulate</span><span class="p">(</span><span class="n">results</span><span class="p">.</span><span class="n">begin</span><span class="p">(),</span><span class="n">results</span><span class="p">.</span><span class="n">end</span><span class="p">(),</span><span class="n">init</span><span class="p">);</span> <span class="c1">// 11
</span><span class="p">}</span>
</code></pre>
</div>

<h2 id="25-识别线程-identifying">2.5 识别线程 Identifying</h2>
<p>First, the identifier for a thread can be obtained from its associated std::thread object by calling the get_id() member function. returns a defaultconstructed std::thread::id object, which indicates “no any thread.”.<br />
线程标识类型是 std::thread::id ，可以通过两种方式进行检索。第一种，可以通过调用 std::thread 对象的成员函数 get_id() 来直接获取。如果 std::thread 对象没有与任何执行线程相关联， get_id() 将返回 std::thread::type 默认构造值，这个值表示“没有线程”。第二种，当前线程中调用 std::this_thread::get_id().</p>

<p>threadsstd::thread::id 类型对象提供相当丰富的对比操作；比如，提供为不同的值进行排序. 标准库也提供 std::hash<std::thread::id> 容器，所以 std::thread::id 也可以作为无序容器的键值。</std::thread::id></p>
<div class="language-c++ highlighter-rouge"><pre class="highlight"><code><span class="n">std</span><span class="o">::</span><span class="kr">thread</span><span class="o">::</span><span class="n">id</span> <span class="n">master_thread</span><span class="p">;</span>
<span class="kt">void</span> <span class="nf">some_core_part_of_algorithm</span><span class="p">()</span>
<span class="p">{</span>
<span class="k">if</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">this_thread</span><span class="o">::</span><span class="n">get_id</span><span class="p">()</span><span class="o">==</span><span class="n">master_thread</span><span class="p">)</span>
<span class="p">{</span>
<span class="n">do_master_thread_work</span><span class="p">();</span>
<span class="p">}</span>
<span class="n">do_common_work</span><span class="p">();</span>
<span class="p">}</span>
</code></pre>
</div>
<p>std::thread::id 可以作为一个线程的通用标识符，当标识符只与语义相关(比如，数组的索
引)时，就需要想其他办法了（例如之前例子中只用循环中的index作为线程的标识）。<br />
The idea is that std::thread::id will suffice as a generic identifier for a thread in
most circumstances; it’s only if the identifier has semantic meaning associated with it
(such as being an index into an array) that alternatives should be necessary.</p>


                </div>
                <div class="read-all">
                    <a  href="/2017/03/06/ccia-2-thread-management/"><i class="fa fa-newspaper-o"></i>Read All</a>
                </div>
                <hr>
              </li>
            
              <li>
                <h2>
                  <a class="post-link" href="/2017/03/06/grof-jump-floor/">Frog Jump Floor</a>
                </h2>
                <div class="label">
                    <div class="label-card">
                        <i class="fa fa-calendar"></i>2017-03-06
                    </div>
                    <div class="label-card">
                        
                    </div>
                    <div class="label-card">
                        
                    </div>

                    <div class="label-card">
                    


<!-- <span class="point">•</span> -->
<span class="categories">
  <i class="fa fa-th-list"></i>
  
    
        <a href="/category/#algo" title="Category: algo" rel="category">algo</a>
    
  

  <!-- <span class="point">•</span> -->
</span>


                    </div>

                    <div class="label-card">
                    
<!-- <span class="point">•</span> -->
<span class="pageTag">
  <i class="fa fa-tags"></i>
  
    
        <a href="/tag/#iteration" title="Tag: iteration" rel="tag">iteration</a>
    
  

</span>

                    </div>
                </div>
                <div class="excerpt">
                    
<div class="language-c++ highlighter-rouge"><pre class="highlight"><code><span class="k">static</span> <span class="kt">int</span> <span class="nf">jump_floor</span> <span class="p">(</span><span class="kt">int</span> <span class="n">number</span><span class="p">)</span>
<span class="p">{</span>
  <span class="cm">/**
   * 一只青蛙一次可以跳上1级台阶，也可以跳上2级。求该青蛙跳上一个n级的台阶总共有多少种跳法.
   * A frog can jump 1 or 2 levels at a time and
   * please calculate how mnay ways to jump to the top of an 'n' level stair
   * Train of Thoughts:
   * when level 1, 1 way to jump
   * when level 2, 2 ways to jump
   * when level 3, 3 ways to jump
   * when level 4, 5 ways to jump
   * when level 5, 8 ways to jump
   * ....
   * when level n, f(n-1)+f(n-2) ways to jump
   */</span>
  <span class="k">if</span> <span class="p">(</span><span class="n">number</span> <span class="o">&lt;=</span> <span class="mi">0</span><span class="p">)</span>
    <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
  <span class="k">if</span> <span class="p">(</span><span class="n">number</span> <span class="o">==</span> <span class="mi">1</span><span class="p">)</span>
    <span class="k">return</span> <span class="mi">1</span><span class="p">;</span>
  <span class="k">if</span> <span class="p">(</span><span class="n">number</span> <span class="o">==</span> <span class="mi">2</span><span class="p">)</span>
    <span class="k">return</span> <span class="mi">2</span><span class="p">;</span>
  <span class="kt">int</span> <span class="n">first</span> <span class="o">=</span> <span class="mi">1</span><span class="p">,</span> <span class="n">second</span> <span class="o">=</span> <span class="mi">2</span><span class="p">,</span> <span class="n">third</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
  <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">3</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;=</span> <span class="n">number</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span>
  <span class="p">{</span>
    <span class="n">third</span> <span class="o">=</span> <span class="n">first</span> <span class="o">+</span> <span class="n">second</span><span class="p">;</span>
    <span class="n">first</span> <span class="o">=</span> <span class="n">second</span><span class="p">;</span>
    <span class="n">second</span> <span class="o">=</span> <span class="n">third</span><span class="p">;</span>
  <span class="p">}</span>
  <span class="k">return</span> <span class="n">third</span><span class="p">;</span>
<span class="p">}</span>
<span class="n">TEST_F</span><span class="p">(</span><span class="n">mpath</span><span class="p">,</span><span class="n">test_jump_floor</span><span class="p">)</span>
<span class="p">{</span>
  <span class="n">ASSERT_EQ</span><span class="p">(</span><span class="n">jump_floor</span><span class="p">(</span><span class="mi">5</span><span class="p">),</span> <span class="mi">8</span><span class="p">);</span>
<span class="p">}</span>
</code></pre>
</div>


                </div>
                <div class="read-all">
                    <a  href="/2017/03/06/grof-jump-floor/"><i class="fa fa-newspaper-o"></i>Read All</a>
                </div>
                <hr>
              </li>
            
              <li>
                <h2>
                  <a class="post-link" href="/2017/03/05/gernric-api-introduction/">Generic</a>
                </h2>
                <div class="label">
                    <div class="label-card">
                        <i class="fa fa-calendar"></i>2017-03-05
                    </div>
                    <div class="label-card">
                        
                    </div>
                    <div class="label-card">
                        
                    </div>

                    <div class="label-card">
                    


<!-- <span class="point">•</span> -->
<span class="categories">
  <i class="fa fa-th-list"></i>
  
    
        <a href="/category/#geco" title="Category: geco" rel="category">geco</a>
    
  

  <!-- <span class="point">•</span> -->
</span>


                    </div>

                    <div class="label-card">
                    
<!-- <span class="point">•</span> -->
<span class="pageTag">
  <i class="fa fa-tags"></i>
  
    
        <a href="/tag/#python" title="Tag: python" rel="tag">python</a>
    
  

</span>

                    </div>
                </div>
                <div class="excerpt">
                    <ul id="markdown-toc">
  <li><a href="#forms" id="markdown-toc-forms">Forms</a></li>
  <li><a href="#links" id="markdown-toc-links">Links</a></li>
</ul>

<h2 id="forms">Forms</h2>
<p><strong>_forms</strong> is used to indicate what request formate to be accepted by server in next game. You can find it in response section in debug page and it is something that looks like this:</p>
<div class="language-json highlighter-rouge"><pre class="highlight"><code><span class="s2">"_forms"</span><span class="err">:</span><span class="w"> </span><span class="p">{</span><span class="w">
    </span><span class="nt">"application/vnd.miko.slots.generic_engine_model_a.earlycollect.bank-v1+json"</span><span class="p">:</span><span class="w"> </span><span class="p">{</span><span class="w">
      </span><span class="nt">"action"</span><span class="p">:</span><span class="w"> </span><span class="s2">"earlycollect_bank"</span><span class="p">,</span><span class="w">
      </span><span class="nt">"$schema"</span><span class="p">:</span><span class="w"> </span><span class="s2">"http://json-schemas.geco.io/slots/earlycollect-v1.json"</span><span class="w">
    </span><span class="p">},</span><span class="w">
    </span><span class="nt">"application/vnd.miko.slots.generic_engine_model_a.earlycollect.collect-v1+json"</span><span class="p">:</span><span class="w"> </span><span class="p">{</span><span class="w">
      </span><span class="nt">"action"</span><span class="p">:</span><span class="w"> </span><span class="s2">"earlycollect_collect"</span><span class="p">,</span><span class="w">
      </span><span class="nt">"perLine"</span><span class="p">:</span><span class="w"> </span><span class="kc">true</span><span class="p">,</span><span class="w">
      </span><span class="nt">"$schema"</span><span class="p">:</span><span class="w"> </span><span class="s2">"http://json-schemas.geco.io/slots/earlycollect-v1.json"</span><span class="p">,</span><span class="w">
      </span><span class="nt">"stake"</span><span class="p">:</span><span class="w"> </span><span class="kc">null</span><span class="p">,</span><span class="w">
      </span><span class="nt">"selectedWinLines"</span><span class="p">:</span><span class="w"> </span><span class="p">[]</span><span class="w">
    </span><span class="p">},</span><span class="w">
    </span><span class="nt">"application/vnd.geco.slots.spin-v1+json"</span><span class="p">:</span><span class="w"> </span><span class="p">{</span><span class="w">
      </span><span class="nt">"action"</span><span class="p">:</span><span class="w"> </span><span class="s2">"spin"</span><span class="p">,</span><span class="w">
      </span><span class="nt">"perLine"</span><span class="p">:</span><span class="w"> </span><span class="kc">true</span><span class="p">,</span><span class="w">
      </span><span class="nt">"$schema"</span><span class="p">:</span><span class="w"> </span><span class="s2">"http://json-schemas.geco.io/slots/spin-v1.json"</span><span class="p">,</span><span class="w">
      </span><span class="nt">"stake"</span><span class="p">:</span><span class="w"> </span><span class="kc">null</span><span class="p">,</span><span class="w">
      </span><span class="nt">"selectedWinLines"</span><span class="p">:</span><span class="w"> </span><span class="p">[]</span><span class="w">
    </span><span class="p">}</span><span class="w">
  </span><span class="p">}</span><span class="err">,</span><span class="w">
  </span><span class="s2">"gamestate"</span><span class="err">:</span><span class="w"> </span><span class="p">{</span><span class="w">
    </span><span class="nt">"stake"</span><span class="p">:</span><span class="w"> </span><span class="mi">0</span><span class="p">,</span><span class="w">
    </span><span class="nt">"win"</span><span class="p">:</span><span class="w"> </span><span class="mf">2.1</span><span class="p">,</span><span class="w">
    </span><span class="nt">"action"</span><span class="p">:</span><span class="w"> </span><span class="s2">"interlevel"</span><span class="p">,</span><span class="w">
    </span><span class="nt">"currentPlay"</span><span class="p">:</span><span class="w"> </span><span class="mi">0</span><span class="p">,</span><span class="w">
    </span><span class="nt">"currentWinnings"</span><span class="p">:</span><span class="w"> </span><span class="mf">2.1</span><span class="p">,</span><span class="w">
</span></code></pre>
</div>

<h2 id="links">Links</h2>
<p><strong>_links</strong> is used as shortcut button that connects to <strong>_forms</strong> via <code class="highlighter-rouge">type</code> field value. It looks like this:</p>
<div class="language-json highlighter-rouge"><pre class="highlight"><code><span class="w"> </span><span class="s2">"_links"</span><span class="err">:</span><span class="w"> </span><span class="p">[</span><span class="w">
    </span><span class="p">{</span><span class="w">
      </span><span class="nt">"href"</span><span class="p">:</span><span class="w"> </span><span class="s2">"http://localhost:6543/game/10?ccy=GBP"</span><span class="p">,</span><span class="w">
      </span><span class="nt">"type"</span><span class="p">:</span><span class="w"> </span><span class="s2">"application/vnd.miko.slots.generic_engine_model_a.earlycollect.bank-v1+json"</span><span class="p">,</span><span class="w">
      </span><span class="nt">"method"</span><span class="p">:</span><span class="w"> </span><span class="s2">"POST"</span><span class="p">,</span><span class="w">
      </span><span class="nt">"rel"</span><span class="p">:</span><span class="w"> </span><span class="s2">"earlycollect_bank"</span><span class="w">
    </span><span class="p">},</span><span class="w">
    </span><span class="p">{</span><span class="w">
      </span><span class="nt">"href"</span><span class="p">:</span><span class="w"> </span><span class="s2">"http://localhost:6543/game/10?ccy=GBP"</span><span class="p">,</span><span class="w">
      </span><span class="nt">"type"</span><span class="p">:</span><span class="w"> </span><span class="s2">"application/vnd.miko.slots.generic_engine_model_a.earlycollect.collect-v1+json"</span><span class="p">,</span><span class="w">
      </span><span class="nt">"method"</span><span class="p">:</span><span class="w"> </span><span class="s2">"POST"</span><span class="p">,</span><span class="w">
      </span><span class="nt">"rel"</span><span class="p">:</span><span class="w"> </span><span class="s2">"earlycollect_collect"</span><span class="w">
    </span><span class="p">},</span><span class="w">
    </span><span class="p">{</span><span class="w">
      </span><span class="nt">"href"</span><span class="p">:</span><span class="w"> </span><span class="s2">"http://localhost:6543/gameplay/27038/client_state"</span><span class="p">,</span><span class="w">
      </span><span class="nt">"type"</span><span class="p">:</span><span class="w"> </span><span class="s2">"application/octet-stream"</span><span class="p">,</span><span class="w">
      </span><span class="nt">"method"</span><span class="p">:</span><span class="w"> </span><span class="s2">"PUT"</span><span class="p">,</span><span class="w">
      </span><span class="nt">"rel"</span><span class="p">:</span><span class="w"> </span><span class="s2">"gameplay-client-state-save"</span><span class="w">
    </span><span class="p">}</span><span class="w">
  </span><span class="p">]</span><span class="err">,</span><span class="w">
</span></code></pre>
</div>
<p>Also, there are clickable buttons shown in debug page that will automatically copy and past the required “form” to request body field. For example, you should see something like this in request body frame after clicking “early_collect (POST)” button: <em>(caution: if you see different things, please ask to redeploy generic backend)</em></p>
<div class="language-json highlighter-rouge"><pre class="highlight"><code><span class="p">{</span><span class="w">
  </span><span class="nt">"action"</span><span class="p">:</span><span class="w"> </span><span class="s2">"earlycollect_collect"</span><span class="p">,</span><span class="w">
  </span><span class="nt">"perLine"</span><span class="p">:</span><span class="w"> </span><span class="kc">true</span><span class="p">,</span><span class="w">
  </span><span class="nt">"$schema"</span><span class="p">:</span><span class="w"> </span><span class="s2">"http://json-schemas.geco.io/slots/earlycollect-v1.json"</span><span class="p">,</span><span class="w">
  </span><span class="nt">"stake"</span><span class="p">:</span><span class="w"> </span><span class="s2">"0.04"</span><span class="p">,</span><span class="w">
  </span><span class="nt">"selectedWinLines"</span><span class="p">:</span><span class="w"> </span><span class="p">[</span><span class="w">
    </span><span class="s2">"0"</span><span class="p">,</span><span class="w">
    </span><span class="s2">"1"</span><span class="p">,</span><span class="w">
    </span><span class="s2">"2"</span><span class="p">,</span><span class="w">
    </span><span class="s2">"3"</span><span class="p">,</span><span class="w">
    </span><span class="s2">"4"</span><span class="p">,</span><span class="w">
    </span><span class="s2">"5"</span><span class="p">,</span><span class="w">
    </span><span class="s2">"6"</span><span class="p">,</span><span class="w">
    </span><span class="s2">"7"</span><span class="p">,</span><span class="w">
    </span><span class="s2">"8"</span><span class="p">,</span><span class="w">
    </span><span class="s2">"9"</span><span class="w">
  </span><span class="p">]</span><span class="w">
</span><span class="p">}</span><span class="w">
</span></code></pre>
</div>
<p>you do not need manully assign values to each field shown above as they have values in default. eg. <code class="highlighter-rouge">"stake":"0.04",</code>. However, sometime you have to manully fill some fields with your own values. For example, after clicking button of “Intervelevl”, you see this in request body frame:</p>
<div class="language-json highlighter-rouge"><pre class="highlight"><code><span class="p">{</span><span class="w">
  </span><span class="nt">"action"</span><span class="p">:</span><span class="w"> </span><span class="s2">"interlevel"</span><span class="p">,</span><span class="w">
  </span><span class="nt">"$schema"</span><span class="p">:</span><span class="w"> </span><span class="s2">"http://json-schemas.geco.io/slots/interlevel-v1.json"</span><span class="w">
</span><span class="p">}</span><span class="w">
</span></code></pre>
</div>
<p>But, the one shown in <em>_forms</em> is looking like this:</p>
<div class="language-json highlighter-rouge"><pre class="highlight"><code><span class="w">  </span><span class="s2">"_forms"</span><span class="err">:</span><span class="w"> </span><span class="p">{</span><span class="w">
    </span><span class="nt">"application/vnd.miko.slots.generic_engine_model_a.interlevel-v1+json"</span><span class="p">:</span><span class="w"> </span><span class="p">{</span><span class="w">
      </span><span class="nt">"action"</span><span class="p">:</span><span class="w"> </span><span class="s2">"interlevel"</span><span class="p">,</span><span class="w">
      </span><span class="nt">"cashShipsCollected"</span><span class="p">:</span><span class="w"> </span><span class="p">[],</span><span class="w">
      </span><span class="nt">"$schema"</span><span class="p">:</span><span class="w"> </span><span class="s2">"http://json-schemas.geco.io/slots/interlevel-v1.json"</span><span class="p">,</span><span class="w">
      </span><span class="nt">"energyShipsCollected"</span><span class="p">:</span><span class="w"> </span><span class="p">[]</span><span class="w">
    </span><span class="p">}</span><span class="w">
  </span><span class="p">}</span><span class="err">,</span><span class="w">
</span></code></pre>
</div>
<p>Obviously,<code class="highlighter-rouge">"energyShipsCollected": []</code> is missing and so you have to manully add it and assign values (here they are ships player catches) in request body frame. after that, it should look like this (assume player catches all energy ships):</p>
<div class="language-json highlighter-rouge"><pre class="highlight"><code><span class="p">{</span><span class="w">
  </span><span class="nt">"action"</span><span class="p">:</span><span class="w"> </span><span class="s2">"interlevel"</span><span class="p">,</span><span class="w">
  </span><span class="nt">"$schema"</span><span class="p">:</span><span class="w"> </span><span class="s2">"http://json-schemas.geco.io/slots/interlevel-v1.json"</span><span class="p">,</span><span class="w">
  </span><span class="nt">"cashShipsCollected"</span><span class="p">:[],</span><span class="w">
  </span><span class="nt">"energyShipsCollected"</span><span class="p">:[</span><span class="s2">"ep1"</span><span class="p">,</span><span class="s2">"ep2"</span><span class="p">,</span><span class="s2">"ep3"</span><span class="p">]</span><span class="w">
</span><span class="p">}</span><span class="w">
</span></code></pre>
</div>
<p>As you can see, <code class="highlighter-rouge">"energyShipsCollected":["ep1","ep2","ep3"]</code> has fixed value like ep1 ep2 ep3. All possible manully -assigned-values are listed below:<br />
“energyShipsCollected”: [“ep1”,”ep2”,”ep3”] // player catches all energy ships<br />
“energyShipsCollected”: [“ep1”] // player catches not all energy ships<br />
“energyShipsCollected”: [] // empty means player catches no energy ships<br />
“cashShipsCollected”: [“cash1”,”cash2”,”cash3”] // player catches all cash ships<br />
“cashShipsCollected”: [“cash1”] // player catches not all cash ships<br />
“cashShipsCollected”: [] // empty means player catches no cash ships</p>


                </div>
                <div class="read-all">
                    <a  href="/2017/03/05/gernric-api-introduction/"><i class="fa fa-newspaper-o"></i>Read All</a>
                </div>
                <hr>
              </li>
            
              <li>
                <h2>
                  <a class="post-link" href="/2017/03/03/ccia-1-hello-world/">CCIA-1-hello-world</a>
                </h2>
                <div class="label">
                    <div class="label-card">
                        <i class="fa fa-calendar"></i>2017-03-03
                    </div>
                    <div class="label-card">
                        
                    </div>
                    <div class="label-card">
                        
                    </div>

                    <div class="label-card">
                    


<!-- <span class="point">•</span> -->
<span class="categories">
  <i class="fa fa-th-list"></i>
  
    
        <a href="/category/#read" title="Category: read" rel="category">read</a>
    
  

  <!-- <span class="point">•</span> -->
</span>


                    </div>

                    <div class="label-card">
                    
<!-- <span class="point">•</span> -->
<span class="pageTag">
  <i class="fa fa-tags"></i>
  
    
        <a href="/tag/#thread" title="Tag: thread" rel="tag">thread</a>&nbsp;
    
        <a href="/tag/#c++" title="Tag: c++" rel="tag">c++</a>
    
  

</span>

                    </div>
                </div>
                <div class="excerpt">
                    <ul id="markdown-toc">
  <li><a href="#12-why-use-concurrency-" id="markdown-toc-12-why-use-concurrency-">1.2 Why use concurrency ?</a></li>
</ul>

<h3 id="12-why-use-concurrency-">1.2 Why use concurrency ?</h3>
<p>There are two main reasons to use concurrency in an application:</p>
<ul>
  <li>Separation of concerns
    <ul>
      <li>Separation of concerns is almost always a good idea when writing software; by grouping <strong>related</strong> bits of code together and keeping <strong>unrelated</strong> bits of code apart, you can make your programs easier to understand and test, and thus less likely to contain bugs.</li>
      <li>Without the explicit use of concurrency you either have to write a <strong>task-switching</strong> framework or <strong>actively</strong> make calls to <strong>unrelated</strong> areas of code during an operation.</li>
      <li>Using threads in this way generally makes the logic in each thread much simpler, because the <strong>interactions</strong> between them can be limited to <strong>clearly identi-fiable points</strong>, rather than having to <strong>intersperse</strong> the logic of the different tasks</li>
      <li>In this case, the number of threads is <strong>independent</strong> of the number of CPU cores
available, because the division into threads is based on the <strong>conceptual design</strong> rather than an attempt to increase throughput.</li>
    </ul>
  </li>
  <li>Performance
    <ul>
      <li>task parallelism 
divide a single task into parts and run each in parallel, thus reducing the
total runtime.</li>
      <li>data parallelism
each thread performs the same operation on different parts of the data.</li>
    </ul>
  </li>
</ul>

                </div>
                <div class="read-all">
                    <a  href="/2017/03/03/ccia-1-hello-world/"><i class="fa fa-newspaper-o"></i>Read All</a>
                </div>
                <hr>
              </li>
            
        </ul>



        <!-- Pagination links -->
        <div class="pagination">
          
            <span class="previous disable"><i class="fa fa-angle-double-left"></i></span>
            <span class="previous disable"><i class="fa fa-angle-left"></i></span>
          
          <span class="page_number ">1/3</span>
          
            <a href="/page2" class="next"><i class="fa fa-angle-right"></i></a>
            <a href="/page3" class="next"><i class="fa fa-angle-double-right"></i></a>
          
        </div>
    </div>
    <!-- <button class="anchor"><i class="fa fa-anchor"></i></button> -->
    <div class="right">
        <div class="wrap">
            <div class="side">
                <div>
                    <i class="fa fa-pencil-square-o" aria-hidden="true"></i>
                    Recent Posts
                </div>
                <ul class="content-ul" recent>
                    
                        <li><a href="/2017/03/12/ccia-3-1-shared-data-protection/">CCIA-3-shared-data-1</a></li>
                    
                        <li><a href="/2017/03/07/csapp-1-preface/">CS:APP-1-Introduction</a></li>
                    
                        <li><a href="/2017/03/06/ccia-2-thread-management/">CCIA-2-basic-thread-mangement</a></li>
                    
                        <li><a href="/2017/03/06/grof-jump-floor/">Frog Jump Floor</a></li>
                    
                        <li><a href="/2017/03/05/gernric-api-introduction/">Generic</a></li>
                    
                        <li><a href="/2017/03/03/ccia-1-hello-world/">CCIA-1-hello-world</a></li>
                    
                        <li><a href="/2017/03/03/algo-is-pop-order/">Is right Pop Sequence ?</a></li>
                    
                        <li><a href="/2017/03/02/tdd-steps/">How to apply tdd</a></li>
                    
                        <li><a href="/2017/03/02/algo-repalce-empty-space/">Replace Empty Space</a></li>
                    
                        <li><a href="/2017/03/01/find-number-in-array/">Find Integer</a></li>
                    
                </ul>
            </div>

            <!-- Content -->
            <div class="side ">
                <div>
                    <i class="fa fa-th-list"></i>
                    Categories
                </div>
                <ul class="content-ul" cate>
                    
                    <li>
                        <a href="/category/#tool" class="categories-list-item" cate="tool">
                            <span class="name">
                                tool
                            </span>
                            <span class="badge">3</span>
                        </a>
                    </li>
                    
                    <li>
                        <a href="/category/#ipc" class="categories-list-item" cate="ipc">
                            <span class="name">
                                ipc
                            </span>
                            <span class="badge">1</span>
                        </a>
                    </li>
                    
                    <li>
                        <a href="/category/#logging" class="categories-list-item" cate="logging">
                            <span class="name">
                                logging
                            </span>
                            <span class="badge">1</span>
                        </a>
                    </li>
                    
                    <li>
                        <a href="/category/#algo" class="categories-list-item" cate="algo">
                            <span class="name">
                                algo
                            </span>
                            <span class="badge">5</span>
                        </a>
                    </li>
                    
                    <li>
                        <a href="/category/#network" class="categories-list-item" cate="network">
                            <span class="name">
                                network
                            </span>
                            <span class="badge">1</span>
                        </a>
                    </li>
                    
                    <li>
                        <a href="/category/#test" class="categories-list-item" cate="test">
                            <span class="name">
                                test
                            </span>
                            <span class="badge">1</span>
                        </a>
                    </li>
                    
                    <li>
                        <a href="/category/#read" class="categories-list-item" cate="read">
                            <span class="name">
                                read
                            </span>
                            <span class="badge">4</span>
                        </a>
                    </li>
                    
                    <li>
                        <a href="/category/#geco" class="categories-list-item" cate="geco">
                            <span class="name">
                                geco
                            </span>
                            <span class="badge">1</span>
                        </a>
                    </li>
                    
                </ul>
            </div>
            <!-- 其他div框放到这里 -->
            <div class="side">
                <div>
                    <i class="fa fa-tags"></i>
                    Tags
                </div>
                <div class="tags-cloud">
                    
                    
                    
                    

                    

                    
                      
                      
                      
                      
                      
                      <a href="/tag/#swig" style="font-size: 18pt; color: #000;">swig</a>
                    
                      
                      
                      
                      
                      
                      <a href="/tag/#script-language" style="font-size: 18pt; color: #000;">script-language</a>
                    
                      
                      
                      
                      
                      
                      <a href="/tag/#c/c++" style="font-size: 18pt; color: #000;">c/c++</a>
                    
                      
                      
                      
                      
                      
                      <a href="/tag/#os" style="font-size: 13.5pt; color: #444;">os</a>
                    
                      
                      
                      
                      
                      
                      <a href="/tag/#lock-free" style="font-size: 9pt; color: #999;">lock-free</a>
                    
                      
                      
                      
                      
                      
                      <a href="/tag/#debug" style="font-size: 9pt; color: #999;">debug</a>
                    
                      
                      
                      
                      
                      
                      <a href="/tag/#list" style="font-size: 9pt; color: #999;">list</a>
                    
                      
                      
                      
                      
                      
                      <a href="/tag/#ordering" style="font-size: 9pt; color: #999;">ordering</a>
                    
                      
                      
                      
                      
                      
                      <a href="/tag/#endian" style="font-size: 9pt; color: #999;">endian</a>
                    
                      
                      
                      
                      
                      
                      <a href="/tag/#memory" style="font-size: 9pt; color: #999;">memory</a>
                    
                      
                      
                      
                      
                      
                      <a href="/tag/#array" style="font-size: 9pt; color: #999;">array</a>
                    
                      
                      
                      
                      
                      
                      <a href="/tag/#binary-search" style="font-size: 9pt; color: #999;">binary-search</a>
                    
                      
                      
                      
                      
                      
                      <a href="/tag/#stack" style="font-size: 13.5pt; color: #444;">stack</a>
                    
                      
                      
                      
                      
                      
                      <a href="/tag/#tdd" style="font-size: 9pt; color: #999;">tdd</a>
                    
                      
                      
                      
                      
                      
                      <a href="/tag/#thread" style="font-size: 18pt; color: #000;">thread</a>
                    
                      
                      
                      
                      
                      
                      <a href="/tag/#c++" style="font-size: 18pt; color: #000;">c++</a>
                    
                      
                      
                      
                      
                      
                      <a href="/tag/#python" style="font-size: 9pt; color: #999;">python</a>
                    
                      
                      
                      
                      
                      
                      <a href="/tag/#iteration" style="font-size: 9pt; color: #999;">iteration</a>
                    
                </div>
            </div>

            <!-- <div class="side">
                <div>
                    <i class="fa fa-external-link"></i>
                    Links
                </div>
                <ul  class="content-ul">

                </ul>
            </div> -->
        </div>
    </div>
</div>
<!-- <script src="/js/scroll.min.js " charset="utf-8"></script> -->
<!-- <script src="/js/pageContent.js " charset="utf-8"></script> -->


    <footer class="site-footer">


    <div class="wrapper">

        <p class="description">
             For my youth dedicated to coding 
        </p>
        <p class="contact">
            Contact me at: 
            <a href="https://github.com/kiddinglife" title="GitHub"><i class="fa fa-github" aria-hidden="true"></i></a>  
            <a href="mailto:jakezhang1989@hotmail.com" title="email"><i class="fa fa-envelope-o" aria-hidden="true"></i></a>       
            <a href="https://www.linkedin.com/in/kiddinglife" title="LinkedIn"><i class="fa fa-linkedin" aria-hidden="true"></i></a>  
        </p>
        <p>
            本站总访问量<span id="busuanzi_value_site_pv"></span>次，本站访客数<span id="busuanzi_value_site_uv"></span>人次，本文总阅读量<span id="busuanzi_value_page_pv"></span>次
        </p>
        <p class="power">
            <span>
                Site powered by <a href="https://jekyllrb.com/">Jekyll</a> & <a href="https://pages.github.com/">Github Pages</a>.
            </span>
            <span>
                Theme designed by <a href="https://github.com/Gaohaoyang">HyG</a>.
            </span>
        </p>
    </div>
</footer>
<script async src="https://dn-lbstatics.qbox.me/busuanzi/2.3/busuanzi.pure.mini.js"></script>

    <div class="back-to-top">
    <a href="#top" data-scroll>
        <i class="fa fa-arrow-up" aria-hidden="true"></i>
    </a>
</div>

    <script src=" /js/main.js " charset="utf-8"></script>
    <script src=" /js/smooth-scroll.min.js " charset="utf-8"></script>
    <script type="text/javascript">
      smoothScroll.init({
        speed: 500, // Integer. How fast to complete the scroll in milliseconds
        easing: 'easeInOutCubic', // Easing pattern to use
        offset: 20, // Integer. How far to offset the scrolling anchor location in pixels
      });
    </script>
    <!-- <script src=" /js/scroll.min.js " charset="utf-8"></script> -->
  </body>

</html>
