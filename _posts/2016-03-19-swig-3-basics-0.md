---
layout: post
title:  "SWIG-3-Basics-0"
date:   2016-03-25 20:10:03
categories: tool
tags:  swig script-language c/c++
---

* content
{:toc}

## 5.2 Wrapping Simple C Declarations
For example, consider the following interface file:
```c++
%module example
%inline %{
extern double sin(double x);
extern int strcmp(const char *, const char *);
extern int Foo;
%}
#define STATUS 50
#define VERSION "1.1"
```
When SWIG creates an extension module, these declarations are accessible as scripting language functions, 
variables, and constants respectively. For example, in python:
```python
>>> example.sin(3)
5.2335956
>>> example.strcmp('Dave', 'Mike')
-1
>>> print example.cvar.Foo
42
>>> print example.STATUS
50
>>> print example.VERSION
1.1
```
Whenever possible, SWIG creates an interface that closely matches the underlying C/C++ code. 
However, due to subtle differences between languages, run-time environments, and semantics, it is not always possible to do so. 

### 5.2.1 Basic Type Handling
In order to build an interface, SWIG has to convert C/C++ datatypes to equivalent types in the target language:

#### 5.2.1.1 Integral
When an integral value is converted from C, a cast is used to convert it to the representation in the target language. 
Thus, a 16 bit short in C may be promoted to a 32 bit integer. When integers are converted in the other direction,
 the value is cast back into the original C type. If the value is too large to fit, _it is silently truncated._

bool data type is cast to and from an integer value of 0 and 1 unless the target language provides a special boolean type.    

unsigned/signed char are special cases that are handled as small 8-bit integers. Normally, the char datatype is mapped as a one-character ASCII string.      

_As a rule of thumb, the int datatype and all variations of char and short datatypes are safe to use. 
For unsigned int and long data types, you will need to carefully check the correct operation of your program after it has been wrapped with SWIG._
 
#### 5.2.1.2 Float
SWIG recognizes the following floating point types : float and double. Floating point numbers are mapped to 
and from the natural representation of floats in the target language. This is almost always a C _double_.

#### 5.2.1.3 Unicode:
For those scripting languages that provide Unicode support, Unicode strings are often available in an 8-bit 
representation such as UTF-8 that can be mapped to the char * type (in which case the SWIG interface will probably work). 

### 5.2.2 Global Variables
Whenever possible, SWIG maps C/C++ global variables into scripting language variables. 

Whenever the scripting language variable is used, the underlying C global variable is accessedã€‚
However, the way to access global variables in different script langs are different. 

Finally, if a global variable has been declared as const, it only supports read-only access. 

For example:
```c++
%module example
double foo;
```
results in a scripting language variable like this:
```c++
# Tcl
set foo [3.5]                   ;# Set foo to 3.5
puts $foo                       ;# Print the value of foo
# Python
cvar.foo = 3.5                  # Set foo to 3.5
print cvar.foo                  # Print value of foo
# Perl
$foo = 3.5;                     # Set foo to 3.5
print $foo, "\n";               # Print value of foo
# Ruby
Module.foo = 3.5               # Set foo to 3.5
print Module.foo, "\n"         # Print value of foo
```

### 5.2.3 Constants  
Constants can be created using #define, enumerations, or a special %constant directive. 
The following interface file shows a few valid constant declarations :
```c++
#define I_CONST       5               // An integer constant
#define PI            3.14159         // A Floating point constant
#define S_CONST       "hello world"   // A string constant
#define NEWLINE       '\n'            // Character constant
enum boolean {NO=0, YES=1};
enum months {JAN, FEB, MAR, APR, MAY, JUN, JUL, AUG,
             SEP, OCT, NOV, DEC};
%constant double BLAH = 42.37;
#define PI_4 PI/4
#define FLAGS 0x04 | 0x08 | 0x40
```

#### 5.2.3.1 Special cases
1.SWIG will not create constants for macros unless the value can be completely determined by the preprocessor.
```c++
#define EXTERN extern
EXTERN void foo();
```
what would the value of a constant called EXTERN would be?  

2.for the same conservative reasons even a constant with a simple cast will be ignored, such as
```c++
#define F_CONST (double) 5 // A floating point constant with cast
```

3.For enumerations, it is critical that the original enum definition be included somewhere 
in the interface file (either in a header file or in the %{ %} block) because it needs the original 
enumeration declaration in order to get the correct enum values as assigned by the C compiler.

#### 5.2.3.2 A brief word about const
Typically, %constant is only used when you want to add constants to the scripting language interface 
that are not defined in the original header file.

If the right-most const occurs after all other type modifiers (such as pointers), then the variable is const. 
Otherwise, it is not. Here are some examples of const declarations:
```c++
const char a;           // A constant character
char const b;           // A constant character (the same)
char *const c;          // A constant pointer to a character
const char *const d;    // A constant pointer to a constant character
```
Here is an example of a declaration that is not const:  
```c++
const char *e; 
```
In this case, the pointer e can change --- it's only the value being pointed to that is read-only.

### 5.2.5 A cautionary tale of char *
When strings are passed from a scripting language to a C char *, the pointer usually points to 
string data stored inside the interpreter.
```c++
char *strcat(char *s, const char *t)
```
your application will perhaps crashes with a segmentation fault or other memory related problem. 
This is because s refers to some internal data in the target language---data that you should mot  be touching.

## 5.3 Pointers and complex objects
---
### 5.3.1 Simple pointers
Pointers to primitive C data types such as:
```c++
int* p_int;
double*** ppp_double;
char** pp_char;
Int* null_ptr=NULL;
```
are fully supported by SWIG.

Rather than trying to convert the data being pointed to into a scripting representation, 
SWIG simply encodes the pointer itself into a representation that contains the actual 
value of the pointer and a type-tag. 

Thus, the SWIG representation of the above pointers (in Tcl), might look like this:
```c++
_10081012_p_int
_1008e124_ppp_double
_f8ac_pp_char
_NULL_p_int
```

All pointers are treated as opaque objects by SWIG. Thus, a pointer may be returned by 
a function and passed around to other C functions as needed.
_(? here is something I feel unclear and need go over in the future.)_

The scripting language representation of a pointer value should never be manipulated directly.  
eg. the numbers used may differ from the actual machine address (e.g., on little-endian machines, 
the digits may appear in reverse order)

### 5.3.2 Run time pointer type checking 
Although this has the potential to cause a crash, NULL pointers are also 
sometimes used as sentinel values or to denote a missing/empty value. 
_Therefore, SWIG leaves NULL pointer checking up to the application_.  
_(? here is something I feel unclear when I wrote this blog and need go 
over in the future.)_


### 5.3.3 Derived types, structs, and classes
For everything else (structs, classes, arrays, etc...) SWIG applies a very simple rule :
> Everything else is a pointer

Suppose you have an interface file like this :
```c++
%module fileio
FILE *fopen(char *, char *);
int fclose(FILE *);
unsigned fread(void *ptr, unsigned size, unsigned nobj, FILE *);
unsigned fwrite(void *ptr, unsigned size, unsigned nobj, FILE *);
void *malloc(int nbytes);
void free(void *);
```
In this file, SWIG doesn't know what a FILE is, but since it's used as a pointer, 
so it doesn't really matter what it is. If you wrapped this module into Python, 
you can use the functions just like you expect :
```python
# Copy a file 
def filecopy(source, target):
  f1 = fopen(source, "r")
  f2 = fopen(target, "w")
  buffer = malloc(8192)
  nbytes = fread(buffer, 8192, 1, f1)
  while (nbytes > 0):
    fwrite(buffer, 8192, 1, f2)
          nbytes = fread(buffer, 8192, 1, f1)
  free(buffer)
```
In this case f1, f2, and buffer are all opaque objects containing C pointers. 
It doesn't matter what value they contain--our program works just fine 
without this knowledge.

When SWIG encounters an undeclared data type, it automatically assumes 
that it is a structure or class.

### 5.3.5 Typedef
Like C, typedef can be used to define new type names in SWIG. For example:
```c++ 
typedef unsigned int size_t;
```

typedef definitions appearing in a SWIG interface are not propagated to the 
generated wrapper code. 

Therefore, they either need to be defined in an 
included header file or placed in the declarations section like this:
```c++
%{
 /* Include in the generated wrapper file */  
typedef unsigned int size_t; 
%}  
/* Tell SWIG about it */  
typedef unsigned int size_t;  
```
or
```c++
%inline %{ typedef unsigned int size_t; %}
```

SWIG tracks typedef declarations and uses this information for run-time 
type checking. 

For instance, if you use the above typedef and had the following function 
declaration:
```c++
void foo(unsigned int *ptr);
```
The corresponding wrapper function will accept arguments of type 
unsigned int * or size_t *.

### 5.4.1 Passing structures by value
For example, consider the following function:
```c++
double dot_product(Vector a, Vector b);
```
To deal with this, SWIG transforms the function to use pointers by creating 
a wrapper equivalent to the following:
```c++
double wrap_dot_product(Vector *a, Vector *b) 
{
    Vector x = *a;
    Vector y = *b;
    return dot_product(x, y);
}
```
In the target language, the dot_product() function now accepts pointers to 
Vectors instead of Vectors. For the most part, this transformation is 
transparent so you might not notice.

### 5.4.2 Return by value
For example, consider the following function:
```c++
Vector cross_product(Vector v1, Vector v2);
```
This function wants to return Vector, but SWIG only really supports pointers. 
As a result, SWIG creates a wrapper like this:
```c++
Vector *wrap_cross_product(Vector *v1, Vector *v2) 
{
        Vector x = *v1;
        Vector y = *v2;
        Vector *result;
        result = (Vector *) malloc(sizeof(Vector));
        *(result) = cross(x, y);
        return result;
}
```
Or if SWIG was run with the -c++ option:
```c++
Vector *wrap_cross(Vector *v1, Vector *v2) 
{
        Vector x = *v1;
        Vector y = *v2;
        Vector *result = new Vector(cross(x, y)); // Uses default copy constructor
        return result;
}
```

In both cases, SWIG allocates a new object and returns a reference to it.
It is up to the user to delete the returned object when it is no longer in use.

Clearly, this will leak memory if you are unaware of the implicit memory
allocation and don't take steps to free the result.

It should also be noted that the handling of pass/return by value in C++ has
some special cases.

For example, the above code fragments don't work correctly if Vector doesn't
define a default constructor. The section on SWIG and C++ has more
 information about this case.

### 5.4.3 Linking to global structure variables
For example, a global variable like this:
```c++
Vector unit_i;
```
gets mapped to an underlying pair of set/get functions like this :
```c++
Vector *unit_i_get()
{
    return &unit_i;
}
void unit_i_set(Vector *value)
{
    unit_i = *value;
}
```
A global variable created in this manner will show up as a pointer in the
target scripting language. It would be an extremely bad idea to free or
destroy such a pointer.

Also, C++ classes must supply a properly defined copy constructor in order
for assignment to work correctly.








